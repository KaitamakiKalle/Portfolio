<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Portfolio</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
    <header>
        <h1>Portfolio</h1>
    </header>
    <nav>
        <a href="index.html">Minä</a>
        <a href="work.html">Projektit</a>
        <a href="contact.html">Yhteystiedot</a>
    </nav>

  <div class="content">
    <div id="home" class="project">
      <h1 >Projektit</h2>
   
    </div>

    <div id="work" class="project">
      
      
      <div class="project-card">
        <h3>DigiMajakka</h3>
        <p>DigiMajakka on ticorporate projektin aikana tehty sovellus johon opiskelijat voivat luoda profiilin ja työnantajat/yksityishenkilöt voivat ilmoittaa projektiluontoisista työtehtävistä sekä esimerkiksi harjoittelupaikoista.</p>
        <p>Projektissa toimin backend kehittäjänä. Backendinä toimii REST rajapinta joka pohjautuu express.js, MySQL ja aws-sdk kirjastoihin.</p>
        <p>Alla on esimerkkejä tekemästäni työstä projektissa. Projektin kaikki koodit löytyvät githubista: <a href="https://github.com/jamktiko/DigiMajakka">https://github.com/jamktiko/DigiMajakka</a></p>
        <h4>Profiili reitin kontrolleri</h4>
        <pre><code>import type express from 'express';
            import queryDb from '../db-connection';
            import * as validation from '../validators/validation';
            import type Profile from '../models/profile-model';
            import CustomError from '../custom-error';
            import convertBodyToQueryFormat from '../functions/convert-body-to-update-string';
            import type {IAuthenticatedRequest} from '../middlewares/auth';
            
            const profileController = {
              // Function to return all profiles
              async findAll(
                _request: express.Request,
                response: express.Response,
                next: express.NextFunction,
              ) {
                try {
                  const data = await queryDb(
                    'SELECT * FROM UserProfile WHERE public = true;',
                    [],
                  );
                  console.log(data);
            
                  response.status(200).json(data);
                } catch (error: unknown) {
                  next(error);
                }
              },
            
              // Return one profile by specific id
              async findById(
                _request: express.Request,
                response: express.Response,
                next: express.NextFunction,
              ) {
                try {
                  const data = await queryDb(
                    'SELECT * FROM UserProfile WHERE userprofileid = ?',
                    [_request.params.profileid],
                  );
            
                  if (data.length <= 0) {
                    throw new Error('No profile found with given id');
                  }
                  console.log(data);
            
                  response.status(200).json(data);
                } catch (error: unknown) {
                  next(error);
                }
              },
            
              // Insert new profile into database
              async createProfile(
                _request: IAuthenticatedRequest,
                response: express.Response,
                next: express.NextFunction,
              ) {
                try {
                  if (typeof _request.user === 'undefined') {
                    throw new Error('User does not exist');
                  }
            
                  // Find users data and citys name that users school is in
                  const userdata = await queryDb(
                    'SELECT UA.email, UA.School_name AS schoolname, SC.City_name AS cityname FROM UserAccount UA INNER JOIN SchoolCity SC ON SC.School_name=UA.School_name WHERE UA.email = ?;',
                    [_request.user.email],
                  );
            
                  if (typeof userdata === 'undefined' || !userdata.length) {
                    throw new Error('User does not exist');
                  }
            
                  // Take users data from array
                  const user = userdata[0];
            
                  // Check that user object has specified keys
                  if ('email' in user && 'cityname' in user && 'schoolname' in user) {
                    // Template profile with placeholder data which will be inserted into database
                    const profile: Profile = {
                      firstname: 'Etunimi',
                      familyname: 'Sukunimi',
                      phonenumber: 'Puhelinnumero',
                      description: 'Kuvaus',
                      lookingfor: 'Mitä etsit',
                      studyfield: 'Koulutusala',
                      yearofstudy: 1,
                      publicity: false,
                      picturelink: '',
                      email: '',
                      cityname: String(user.cityname),
                      accountemail: String(user.email),
                      schoolname: String(user.schoolname),
                    };
            
                    // Insert placeholder data to users profile
                    const insertedProfile = await queryDb(
                      'INSERT INTO UserProfile (firstname, familyname, phonenumber, aboutme, lookingfor, studyfield, yearofstudy, public, picturelink, email, City_name, UserAccount_email, UserAccount_School_name) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
                      Object.values(profile),
                    );
            
                    console.log(insertedProfile);
            
                    response.status(201).json({
                      message: 'Profile created succesfully',
                      success: true,
                    });
                  } else {
                    throw new TypeError('Error when trying to create new profile');
                  }
                } catch (error: unknown) {
                  next(error);
                }
              },
            
              // Updates profile
              async updateProfile(
                _request: express.Request,
                response: express.Response,
                next: express.NextFunction,
              ) {
                try {
                  // Check that phone number is in valid format if it is provided
                  if (
                    _request.body.phonenumber &&
                    !validation.validatePhoneNumber(_request.body.phonenumber)
                  ) {
                    throw new CustomError('Phonenumber is not valid', 400);
                  }
                  // Check that email is in valid format if it is provided
                  if (
                    _request.body.email &&
                    !validation.validateEmail(_request.body.email)
                  ) {
                    throw new CustomError('Email is not valid', 400);
                  }
            
                  // Convert request body to sql query and query parameters
                  // Convert function is used here because fields that user wants to update is random
                  // Because of this constant sql query cannot handle all requests
                  const {sql, sqlparams} = convertBodyToQueryFormat(
                    _request,
                    'UserProfile',
                    'userprofileid',
                  );
            
                  const update = await queryDb(sql, [
                    ...sqlparams,
                    _request.params.profileid,
                  ]);
            
                  console.log('Update succesfull');
            
                  console.log(update);
            
                  response.status(200).json({
                    message: 'Updated profile succesfully',
                    success: true,
                  });
                } catch (error: unknown) {
                  next(error);
                }
              },
            
              // Deletes profile by id
              async deleteProfile(
                _request: express.Request,
                response: express.Response,
                next: express.NextFunction,
              ) {
                try {
                  const result = await queryDb('CALL deleteProfile(?);', [
                    _request.params.profileid,
                  ]);
            
                  console.log(result);
            
                  response.status(200).json({
                    message: 'Deleted profile succesfully',
                    success: true,
                  });
                } catch (error: unknown) {
                  next(error);
                }
              },
            
              // Find profile by user email
              async findByEmail(
                _request: IAuthenticatedRequest,
                response: express.Response,
                next: express.NextFunction,
              ) {
                try {
                  let userEmail = '';
            
                  if (_request.user && typeof _request.user.email === 'string') {
                    userEmail = _request.user.email;
                  } else {
                    throw new Error('Token is not valid or email not received in token');
                  }
            
                  const data = await queryDb(
                    'SELECT * FROM UserProfile WHERE UserAccount_email = ?',
                    [userEmail],
                  );
            
                  if (data.length <= 0) {
                    throw new Error('No profile found with given email');
                  }
            
                  console.log(data);
            
                  response.status(200).json(data);
                } catch (error: unknown) {
                  next(error);
                }
              },
            };
            export default profileController;</code></pre>

        <h4>Profiili reitti</h4>
        <pre><code>
            import express from 'express';
import profileC from '../controllers/profile-controller';
import bodyChecker from '../middlewares/body-check';
import {authHandler} from '../middlewares/auth';
import userCheck from '../middlewares/user-check';
// eslint-disable-next-line new-cap
const profileRouter = express.Router();

// Route to get all profiles
// /profiles/
profileRouter.get('/', profileC.findAll);

// Route to get profile with specific id
// /profiles/:id
profileRouter.get('/:profileid', profileC.findById);

// Route to post profile
// /profiles/
profileRouter.post('/', authHandler, bodyChecker, profileC.createProfile);

// Route to update profile
// /profiles/:id
profileRouter.put(
  '/:profileid',
  bodyChecker,
  authHandler,
  userCheck,
  profileC.updateProfile,
);

// Deletes profile by id
// /profiles/:id
profileRouter.delete(
  '/:profileid',
  authHandler,
  userCheck,
  profileC.deleteProfile,
);

// Find profile by useraccount email
// /profiles/email/:email
profileRouter.get('/user/email', authHandler, profileC.findByEmail);

export = profileRouter;
        </code></pre>

        <h4>Käyttäjänhallintaa varten tehty luokka. Rakennettu AWS:n cognito palvelun päälle</h4>
        <pre><code>
            /* eslint-disable require-jsdoc */
/* eslint-disable valid-jsdoc */
/* eslint-disable arrow-parens */
/* eslint-disable @typescript-eslint/comma-dangle */

/* eslint-disable @typescript-eslint/naming-convention */
import process from 'node:process';
import dotenv from 'dotenv';
import {CognitoIdentityServiceProvider} from 'aws-sdk';
dotenv.config();
import {
  AuthenticationDetails,
  CognitoUser,
  CognitoUserAttribute,
  CognitoUserPool,
} from 'amazon-cognito-identity-js';

class CognitoHelper {
  public userPool: CognitoUserPool;
  public cognitoIdentity: CognitoIdentityServiceProvider;

  constructor() {
    this.userPool = new CognitoUserPool({
      UserPoolId: process.env.USER_POOL_ID ?? '',
      ClientId: process.env.CLIENT_ID ?? '',
    });
    this.cognitoIdentity = new CognitoIdentityServiceProvider({
      accessKeyId: process.env.COGNITO_ACCESS_KEY,
      secretAccessKey: process.env.COGNITO_SECRET_KEY,
      region: process.env.REGION,
    });
  }

  /**
   * Method that signs new user to cognito and database
   * @param {string} email users email
   * @param {string} password users password
   * @return {Promise} resolved promise
   */
  async signUp(email: string, password: string) {
    return new Promise((resolve, reject) => {
      const attributeList: CognitoUserAttribute[] = [
        new CognitoUserAttribute({
          Name: 'email',
          Value: email,
        }),
      ];

      // Signup user to cognito
      this.userPool.signUp(
        email,
        password,
        attributeList,
        [],
        (error, result) => {
          if (error) {
            reject(error);
          }

          // If signup was succesfull return username
          resolve(result?.user.getUsername());
        },
      );
    });
  }

  /**
   * Method that confirms user registration with code that cognito sent via email
   * @param {string} email users email
   * @param {string} code users confirmation code received via email
   * @return {Promise} resolved promise
   */
  async confirmSignUp(email: string, code: string) {
    // Create new instance of CognitoUser
    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      // Use cognitoUser class method to verify confirmation code
      cognitoUser.confirmRegistration(code, true, (error, result) => {
        if (error) {
          reject(error);
        }

        resolve(JSON.stringify(result));
      });
    });
  }

  /**
   * Method to resend confirmation code to user
   * @param {string} email users email
   * @return {promise} resolved promise
   */
  async resendConfirmCode(email: string) {
    // Create new instance of CognitoUser

    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      // Use class method to resend confirmation code
      cognitoUser.resendConfirmationCode((error, result) => {
        if (error) {
          reject(error);
        }

        resolve(JSON.stringify(result));
      });
    });
  }

  /**
   * Method to sign user in
   * @param {string} email users registered email
   * @param {string} password users password
   * @return {Promise} resolved promise
   */
  async signIn(email: string, password: string) {
    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      const authenticationDetails = new AuthenticationDetails({
        Username: email,
        Password: password,
      });

      this.cognitoIdentity.adminGetUser(
        {
          UserPoolId: process.env.USER_POOL_ID || '',
          Username: email || '',
        },
        (error) => {
          if (error) reject(error); // an error occurred
        },
      );

      cognitoUser.authenticateUser(authenticationDetails, {
        // If sign in was success check if user has confirmed their account with code
        onSuccess(session, userConfirmationNecessary) {
          if (userConfirmationNecessary) {
            resolve({userConfirmationNecessary});
          }

          // In case of everything is ok send token of signed in user forward

          resolve({
            accessToken: session.getAccessToken().getJwtToken(),
          });
        },
        onFailure(error) {
          reject(error);
        },
      });
    });
  }

  /**
   * Method that signs user out
   * @param {string} email users email
   * @return {Promise} resolved promise
   */
  async signOut(email: string) {
    return new Promise((resolve) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      cognitoUser.signOut(() => {
        resolve('Signed out successfully');
      });
    });
  }

  /**
   * Method to for authenticated user to delete their account/data from cognito and database
   * @param {string} email users email
   * @param {string} password users password fro authentication
   * @return {Promise} promise
   */
  async deleteUser(email: string, password: string) {
    return new Promise((resolve, reject) => {
      // Create new instance of cognitoUser
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });
      // Details for authentication
      const authenticationDetails = new AuthenticationDetails({
        Username: email,
        Password: password,
      });

      // Try to authenticate user
      cognitoUser.authenticateUser(authenticationDetails, {
        // If sign in was success check if user has confirmed their account with code
        onSuccess(_session, userConfirmationNecessary) {
          if (userConfirmationNecessary) {
            resolve({userConfirmationNecessary});
          }

          // On successfull login delete user
          cognitoUser.deleteUser((error, result) => {
            if (error) {
              reject(error);
            }

            console.log(result);

            resolve(result);
          });
        },
        onFailure(error) {
          reject(error);
        },
      });
    });
  }

  /**
   * Method to start password reset workflow. This will send email with confirmation code to user
   * @param {string} email users email
   * @return {Promise} promise
   */
  async resetPassword(email: string) {
    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      this.cognitoIdentity.adminGetUser(
        {
          UserPoolId: process.env.USER_POOL_ID || '',
          Username: email || '',
        },
        (error) => {
          if (error) reject(error); // an error occurred
        },
      );

      cognitoUser.forgotPassword({
        onSuccess: function (result) {
          console.log('call result: ' + result);
          resolve(result);
        },
        onFailure: function (error) {
          reject(error);
        },
      });
    });
  }

  /**
   * Method to complete password reset request
   * @param {string} email users email
   * @param {string} confirmationCode password reset confirmation code received via email
   * @param {string} newPassword new password provided by user
   * @return promise
   */
  async confirmPassword(
    email: string,
    confirmationCode: string,
    newPassword: string,
  ) {
    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });
      cognitoUser.confirmPassword(confirmationCode, newPassword, {
        onFailure(error) {
          reject(error);
        },
        onSuccess() {
          resolve('Password reset success');
        },
      });
    });
  }
}

export default CognitoHelper;
        </code></pre>
<h4>Middleware autentikointia varten</h4>
<pre><code>
    import process from 'node:process';
import {CognitoIdentityServiceProvider} from 'aws-sdk';
import type express from 'express';

// Cognito service
const identityServiceProvider = new CognitoIdentityServiceProvider({
  region: process.env.REGION,
});

// Type for user attribute. Used to extend request
export type IUser = {
  id: string | undefined;
  email: string | undefined;
};

// Extended Request type providing user attribute and authorization header
export type IAuthenticatedRequest = {
  user?: IUser;
  headers: {
    authorization?: string;
  };
} & express.Request;

/**
 * Checks that there is token and places users information from decoded token to requests user attribute
 * @param  {IAuthenticatedRequest} _request  express request
 * @param {express.Response} _response express response
 * @param {express.NextFunction} next express next function
 */
export const authHandler = async (
  _request: IAuthenticatedRequest,
  _response: express.Response,
  next: express.NextFunction,
) => {
  try {
    // Check that there is authorization header
    if (_request.headers.authorization) {
      const token = _request.headers.authorization;

      // Get raw user data from token
      const rawUser = await identityServiceProvider
        .getUser({AccessToken: token})
        .promise();

      // Place cognito id and email to requests user attribute
      _request.user = {
        id: rawUser.UserAttributes.find((attr) => attr.Name === 'sub')?.Value,
        email: rawUser.UserAttributes.find((attr) => attr.Name === 'email')
          ?.Value,
      };
      // Move to next middleware
      next();
    } else {
      throw new Error('No authorization header received');
    }
  } catch (error: unknown) {
    next(error);
  }
};
</code></pre>
<h4>Funktioita syötteiden validointia varten</h4>
<pre><code>
    /* eslint-disable valid-jsdoc */
/* eslint-disable operator-linebreak */

/**
 * Validates email address
 * @param email email to validate
 * @param schoolemailend schools unique email ending to check that user really is student from the school
 * @returns boolean if email was valid or not
 */
export const validateEmail = (email: string) => {
  // Email regular expression taken from website: https://emailregex.com/
  const expression =
    /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[(?:\d{1,3}\.){3}\d{1,3}])|(([a-zA-Z\-\d]+\.)+[a-zA-Z]{2,}))$/;

  // Check that both validation criteria passes
  const validation = expression.test(email);

  if (validation) {
    return true;
  }

  return false;
};

/**
 * Validates phonenumber
 * @param phoneNumber phonenumber to validate
 * @returns boolean if phonenumber was valid or not
 */
export const validatePhoneNumber = (phoneNumber: string) => {
  // Phonenumber regular expressions taken from website: https://regex101.com/library/ffGtsW

  // Can be two differen formats
  const expression =
    /^((04\d)(\s?|-?)|050(\s?|-?)|0457(\s?|-?)|\+?358(\s?|-?)50|0358(\s?|-?)50|00358(\s?|-?)50|\+?358(\s?|-?)4\d|0358(\s?|-?)4\d|00358(\s?|-?)4\d)(\s?|-?)((\d{3,4})(\s|-)?\d{1,4})$/;

  const validate = expression.test(phoneNumber);

  // If either format passes then return true
  if (validate) {
    return true;
  }

  return false;
};

export const validateDate = (date: string) => {
  if (date.match(/^\d{4}\-(0?[1-9]|1[012])\-(0?[1-9]|[12][0-9]|3[01])$/)) {
    return true;
  }
  return false;
};
</code></pre>

<h4>AWS luotu arkkitehtuuri sovellusta varten</h4>
<pre><img src="./img/aws.png" alt="aws-arkkitehtuuri"></pre>

<h4>Tietokannan er-malli</h4>
<img src="./img/er-malli.png" alt="er-malli">

<h4>Esimerkki tietokantaan luoduista proceduureista ja eventeistä</h4>
<h5>Proceduuri käyttäjän poistoa varten</h5>
<img src="./img/proceduuri.png" alt="proceduuri">
<h5>Event vanhojen työilmoitusten piilottamiseksi</h5>
<img src="./img/sqlevent.png" alt="sql-event">


      </div>

      <div class="project-card">
        <h3>Project 1</h3>
        <p>Koneoppiminen web-sovelluksissa kurssille tekemäni lopputyö.</p>
        <pre><code>const tf = require('@tensorflow/tfjs-node');
            const fs = require('fs');
            const path = require('path');
            // Funktio saa parametrina kansion osoitteen jossa kuvat ovat ja labelin joka kyseisille kuville annetaan
            // Kuvat otetaan kansiosta ja muutetaan tensoreiksi jonka jälkeen niistä tehdään objekteja
            // objetkit sisältävät kuva tensorin ja sitä vastaavan label arvon eli muoto on {xs, ys}
            // Funktio toimii vain kun kyseessä on kuvien luokittelu koska parametrinä määritelty label annetaan kaikille
            // kansiossa oleville kuville (esim. 0 tai 1)
            async function imgsToObjArr(imgArrSrc = '', label) {
              // Objektit tallennetaan arr taulukkoon
              const arr = [];
              // Haetaan kaikki tiedostonimet readdirSync metodilla
              const filenames = await fs.readdirSync(imgArrSrc);
            
              // Jokainen tiedosto käydään erikseen lävitse
              await filenames.forEach((file) => {
                // tarkistetaan että tiedoston pääte on jpg tai jpeg jotta mahdolliset virheelliset tiedostot saadaa
                // karsittua pois
                if (path.extname(file) == '.jpg' || path.extname(file) == '.jpeg') {
                  // koska kansion tiedostojen nimet ovat sring muodossa filenames taulukossa saadaan kansiopolusta ja
                  // filenames taulukon alkiosta yksittäisen kuvan osoite readFileSync metodille
                  const img = fs.readFileSync(`${imgArrSrc}/${file}`);
            
                  // Kun kuva on haettu img muuttujaan se muutetaan tensoriksi tensorflown decodeImage metodilla
                  const imgtensor = tf.node.decodeImage(img, 3);
            
                  // Kuvat ovat yleensä valtavan kokoisia ja maskin tunnistamiseen kuvasta ei todellakaan tarvita
                  // kovinkaan tarkkaa kuvaa joten kuvat pienennetään 64x64 pikselin kokoisiksi
                  const imgResized = tf.image.resizeBilinear(imgtensor, [64, 64]);
            
                  // lisätään kuva parametrina annetun labelin kanssa palautettavaan taulukkoon
                  arr.push({ img: imgResized, label: label });
                }
              });
            
              return arr;
            }
            
            // Funktio erottaa xs ja ys arvot omiin taulukkoihinsa objekti taulukosta
            function getValsFromObjArr(objArr) {
              // otetaan xs arvot mapilla omaan taulukkoonsa
              const xsArr = objArr.map((elem) => {
                return elem.img;
              });
              // otetaan ys arvot mapilla omaan taulukkoonsa ja muutetaan ne onehot muotoon
              const ysArr = objArr.map((elem) => {
                return elem.label === 1 ? [1, 0] : [0, 1];
                // return elem.label;
              });
              return {
                xsArr,
                ysArr,
              };
            }
            
            // Funktio normalisoi tensorin
            // Funktiolle voidaan syöttää minimi ja maksimi arvot jolloin se käyttää niitä eikä laske arvoja
            // syötetystä tensorista
            // Jos arvoja ei anneta ne lasketaan tensorista ja myös palautetaan myöhempää käyttöä varten
            async function normalize(tensor, maxVal, minVal) {
              // Jos min ja max arvot on annettu käytetään niitä
              if (maxVal && minVal) {
                const max = maxVal;
                const min = minVal;
                return tensor.sub(min).div(max.sub(min));
              } else {
                // muulloin ne lasketaan syötetystä tensorista
                const max = tf.max(tensor);
                const min = tf.min(tensor);
                // Tällöin palautuu objekti joka sisältää normalisoidun tensorin ja min sekä max arvot
                return { normlizedTensor: tensor.sub(min).div(max.sub(min)), min, max };
              }
            }
            
            // createModel luo modelin
            // Koska kyseessä on kuvanluokittelu tehtävä käytetään convolutionaalista neuroverkkoa
            /*
            Verkon rakenne on:
            
            convolutional layer(relu) + Maxpooling layer
            convolutional layer(relu) + Maxpooling layer
            convolutional layer(relu) + Maxpooling layer
            flatten layer
            dense layer(relu)
            dense layer(relu)
            dense layer(softmax) eli output
            
            */
            
            // Funktio jolla voidaan erottaa taulukosta haluttu määrä testi dataa
            // parametrina annetava taulukko josta data halutaan erottaa mutatoidaan tarkoituksella ettei
            // testidata sekoitu harjoitusdataan
            function separateTestData(amount, arr) {
              // Leikataan splicella taulukosta haluttu määrä testidataa
              const testArr = arr.splice(
                arr.length * (1 - amount),
                arr.length - arr.length * amount
              );
              return testArr;
            }
            
            function createModel() {
              const model = tf.sequential();
              // Convolutionaalinen layer
              model.add(
                tf.layers.conv2d({
                  filters: 16,
                  kernelSize: [3, 3],
                  activation: 'relu',
                  inputShape: [64, 64, 3],
                })
              );
              // pooling layer
              model.add(tf.layers.maxPooling2d([4, 4]));
              model.add(
                tf.layers.conv2d({
                  filters: 8,
                  kernelSize: [3, 3],
                  activation: 'relu',
                })
              );
            
              model.add(tf.layers.maxPooling2d([2, 2]));
              model.add(
                tf.layers.conv2d({
                  filters: 2,
                  kernelSize: [3, 3],
                  activation: 'relu',
                })
              );
              model.add(tf.layers.maxPooling2d([1, 1]));
              model.add(tf.layers.flatten());
              model.add(tf.layers.dense({ units: 10, activation: 'relu' }));
              model.add(tf.layers.dense({ units: 5, activation: 'relu' }));
              model.add(tf.layers.dense({ units: 2, activation: 'softmax' }));
            
              // Modelin kääntäminen
              model.compile({
                optimizer: tf.train.adam(0.01),
                // Koska kyseessä on kuvanluokittelu jossa output on muodossa [0,1] eli sisältää kaksi todennäköisyyttä
                // käytetään categoricalCrossentropy loss funktiota
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy'],
              });
              return model;
            }
            
            async function run() {
              // haetaan kuvat ja labelit
            
              // Maskittomien kuvat sijaitsevat './0' kansiossa ja maskillisten kuvat './1' kansiossa
            
              // Maskittomien kuvat
              const imagesObj0 = await imgsToObjArr('./0', 0);
            
              // Maskillisten kuvat
              const imagesObj1 = await imgsToObjArr('./1', 1);
            
              // yhdistetään taulukot myöhempää käsittelyä varten
              const imagesObjmerged = imagesObj0.concat(imagesObj1);
            
              // Koska data on tällä hetkellä järjestetty niin että maskittomien kuvat ovat peräkkäin ennen maskillisten kuvia
              // pitää data sekoittaa että neuroverkko saa kumpiakin kuvia harjoittaessa satunnaisessa järjestyksessä
              // Sekoitetaan tensorflown shuffle() metodilla
              tf.util.shuffle(imagesObjmerged);
            
              // Muutetaan {kuva, label} objektejen kuvat ja labelit omiksi taulukoikseen
              // Tuloksena on siis xs taulukko ja ys taulukko
              const { xsArr, ysArr } = await getValsFromObjArr(imagesObjmerged);
            
              // Kuinka paljon testidataa halutaan erottaa 0.1 = 10%
              const testAmount = 0.1;
            
              // Erotetaan splicella xs taulukosta haluttu määrä testidataa
              const testXsArr = separateTestData(testAmount, xsArr);
              // Erotetaan splicella ys taulukosta haluttu määrä testidataa
              const testYsArr = separateTestData(testAmount, ysArr);
            
              // Taulukot muunnetaan tensoreiksi
            
              // koska xsArr taulukko sisältää tensoreita muutetaan se tensoriksi käyttämällä tensorflown
              // stack() metodia. Metodi muuttaa juurikin tensoreita sisältävän taulukon tensoriksi
              const xsTensorUnNlized = tf.stack(xsArr);
            
              // xs tensori pitää vielä normalisoida
              // koska max ja min arvoja tarvitaan vielä myöhemmin ne otetaan myös talteen
              // muuttujiin max ja min
              const {
                normlizedTensor: xsTensor,
                max,
                min,
              } = await normalize(xsTensorUnNlized);
            
              // muutetaan ys taulukko tensoriksi
              const ysTensor = await tf.tensor(ysArr);
            
              // Koska haluamme käyttää min ja max arvoja myöhemmin valmiin tallennetun modelin kanssa
              // Tallennetaan ne tekstitiedostoon
              console.log(max);
              const maxData = `${max.dataSync()}`;
              const minData = `${min.dataSync()}`;
              fs.writeFileSync('./min_max_vals/max.txt', maxData);
              fs.writeFileSync('./min_max_vals/min.txt', minData);
            
              // Luodaan model
              const model = await createModel();
            
              // Harjoitetaan model harjoitusdatalla
              await model.fit(xsTensor, ysTensor, {
                epochs: 50,
                // Validationsplit ottaa annetun määrän harjoitusdataa joka kierroksella ja validoi kierroksen tulosta
                // jo harjoittaessa
                validationSplit: 0.1,
                callbacks: {
                  // Seurataan lossia harjoituksen ajan console.log:lla  epoch ja loss
                  onEpochEnd: async (epoch, logs) => {
                    console.log('Epoch: ' + epoch + ' Loss: ' + logs.loss);
                  },
                },
              });
            
              // Tehdään testi xs arvoista tensori ja normalisoidaan sen arvot. Huomaa että tässä käytetään
              // jo tiedettyjä min ja max arvoja
              const testTensorXS = await normalize(tf.stack(testXsArr), max, min);
            
              // Tehdään test ys arvoista tensori
              const testTensorYS = tf.tensor(testYsArr);
            
              // Evaluoidaan modeli testidatalla
              const result = await model.evaluate(testTensorXS, testTensorYS, {
                batchSize: 32,
              });
            
              console.log('loss');
              // evaluoinnin loss
              result[0].print();
              console.log('accuracy');
              // evaluoinnin accuracy
              result[1].print();
            
              // Testataan modelia vielä omalla oikealla kuvalla
              // haetaan kuva readFileSync metodilla
              const testImage = await fs.readFileSync('./testImages/test1.jpg');
              // Muutetaan kuva tensoriksi decodeImage metodilla
              let testImgTensor = await tf.node.decodeImage(testImage, 3);
              // Muutetaan kuva oikeaan kokoon
              testImgTensor = await tf.image.resizeBilinear(testImgTensor, [64, 64]);
              // Normalisoidaan tensori
              testImgTensor.print();
              testImgTensor = await normalize(testImgTensor, max, min);
            
              // Laajennetaan testi tensorin ulottovuutta jotta muoto on sopiva inputille
              testImgTensor = testImgTensor.expandDims(0);
            
              // suoritetaan ennustus
              const prediction = model.predict(testImgTensor);
              // tulostetaan ennustus
              prediction.print();
              // ennustuksen ensimmäinen alkio kertoo millä todennäköisyydellä kuvan henkilöllä on maski naamalla
              console.log(prediction.dataSync()[0]);
            
              // Tallennetaan modeli
              // Kommentoitu pois koska hyvä modeli on jo tallennettuna
              // const saveResult = await model.save(
              //   'file:////Users/kallekaitamaki/Documents/imageClassificator/faceMaskClassifier'
              // );
            }
            
            run();</code></pre>
      </div>


      <div class="project-card">
        <h3>Backend 1 kurssin lopputyö</h3>
        <p>Yksinkertainen REST api jossa on nettiauto.com sivuston kaltainen toiminnallisuus autojen tietojen käsittelyyn.</p>
        <p>Projekti toteutettu express.js ja mongoose kirjastoilla.</p>
        <p>Projektin github: <a href="https://github.com/KaitamakiKalle/car_restapi">https://github.com/KaitamakiKalle/car_restapi</a></p>
        <h4>Auto datan kontrolleri</h4>
        <pre><code>const Car = require('../models/Car');
            const User = require('../models/User');
            
            // Kaikkien autojen haku
            exports.findAll = (req, res) => {
              Car.find()
                .then((response) => {
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(400).send({
                    message: 'Error occured',
                    error: error,
                  });
                });
            };
            
            // Auton haku id:n perusteella
            exports.findByID = (req, res) => {
              Car.find({ _id: req.params.id })
                .then((response) => {
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(400).send({
                    message: 'Error occured',
                    error: error,
                  });
                });
            };
            
            // Auton haku rekisterinumeron perusteella
            exports.findByLicense = (req, res) => {
              Car.find({ license: req.params.license })
                .then((response) => {
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(400).send({
                    message: 'Error occured',
                    error: error,
                  });
                });
            };
            
            // Auton lisäys kantaan
            exports.add = (req, res) => {
              // Sijoitetaan käyttäjänimi pyynnön bodyyn
              req.body.user = req.decoded.username;
              // lisättävän auton tiedot tulevat pyynnön bodyssä
              Car.create(req.body)
                .then((response) => {
                  // kun käyttäjälle lisätään auto myös hänen autojen määrää on lisättävä yhdellä
                  User.updateOne(
                    { username: req.decoded.username },
                    { $inc: { numOfCars: 1 } }
                  ).then((response) => {
                    console.log(response);
                  });
                  console.log('Document added succesfully');
                  res.status(201).json(response);
                })
                .catch((error) => {
                  res.status(error.status || 400).send({
                    message: 'Error when posting data',
                    error: error,
                  });
                });
            };
            
            // Auton poisto kannasta id:n perusteella
            exports.delByID = (req, res) => {
              Car.findOneAndDelete({ _id: req.params.id })
                .then((response) => {
                  User.updateOne(
                    { username: response.user },
                    { $inc: { numOfCars: -1 } }
                  ).then((response) => {
                    console.log(response);
                  });
                  console.log(`Deleted car with license:${response.license} succesfully`);
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(error.status || 400).send({
                    message: 'Error when deleting data',
                    error: error,
                  });
                });
            };
            
            // Auton poisto rekisterinumeron perusteella
            exports.del = (req, res) => {
              Car.findOneAndDelete({ license: req.params.license })
                .then((response) => {
                  User.updateOne(
                    { username: response.user },
                    { $inc: { numOfCars: -1 } }
                  ).then((response) => {
                    console.log(response);
                  });
                  console.log(`Deleted car with license:${response.license} succesfully`);
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(error.status || 400).send({
                    message: 'Error when deleting data',
                    error: error,
                  });
                });
            };
            
            // Pyynnön ensimmäinen parametri kertoo päivitettävän auton rekisterinumeron
            // Toinen parametri kertoo tiedon joka halutaan päivittää
            // Kolmas parametri kertoo päivitetyn arvon valitulle tiedolle
            exports.updateByIDParams = (req, res) => {
              Car.updateOne(
                { _id: req.params.id },
                { 'req.params.field': req.params.value }
              )
                .then((response) => {
                  console.log('Update succesfull');
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(400).send({
                    message: 'Update failed',
                    error: error,
                  });
                });
            };
            
            // Autojen tietojen päivitys id:n perusteella
            exports.updateByID = (req, res) => {
              Car.updateOne({ _id: req.params.id }, req.body)
                .then((response) => {
                  // Tarkistetaan että käyttäjä joka yrittää muokata auton tietoja on auton omistaja tai admin
            
                  console.log('Update succesfull');
                  res.status(201).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(error.status || 400).send({
                    message: 'Error when updating data',
                    error: error,
                  });
                });
            };
            
            // Autojen tietojen päivitys rekisterinumeron perusteella
            exports.updateByLicense = (req, res) => {
              Car.updateOne({ license: req.params.license }, req.body)
                .then((response) => {
                  // Tarkistetaan että käyttäjä joka yrittää muokata auton tietoja on auton omistaja tai admin
            
                  console.log('Update succesfull');
                  res.status(201).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(error.status || 400).send({
                    message: 'Error when updating data',
                    error: error,
                  });
                });
            };
            
            // Auton haku käyttäjänimen perusteella
            exports.findByOwner = (req, res) => {
              Car.find({ user: req.params.user })
                .then((response) => {
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(error.status || 400).send({
                    message: 'Error when finding data',
                    error: error,
                  });
                });
            };
            
            // Autojen haku vuosimallin perusteella
            exports.findByYear = (req, res) => {
              Car.find({ year: req.params.year })
                .then((response) => {
                  console.log('Find succesfull');
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(400).send({
                    message: error.message,
                    error: error,
                  });
                });
            };
            
            // Autojen haku vuosimallin perusteella tietyltä vuosi väliltä
            exports.findBetweenYear = (req, res) => {
              Car.find({ year: { $gte: req.params.min, $lte: req.params.max } })
                .then((response) => {
                  console.log('Find succesfull');
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(400).send({
                    message: error.message,
                    error: error,
                  });
                });
            };
            
            // Haku moottorin koon perusteella
            exports.findByDisplacement = (req, res) => {
              Car.find({
                'motor.displacement': req.params.displacement,
              })
            
                .then((response) => {
                  console.log('Find succesfull');
                  res.status(200).json(response);
                })
                .catch((error) => {
                  console.error(error);
                  res.status(400).send({
                    message: error.message,
                    error: error,
                  });
                });
            };</code></pre>

            <h4>Auton model</h4>
            <pre><code>
                const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const MotorSchema = require('./Motor');
const Car = new Schema({
  license: {
    type: String,
    maxlength: 7,
    match: /[A-Z]{3}-[0-9]{3}/,
    minlength: 7,
    unique: true,
    required: true,
  },
  brand: {
    type: String,
    maxlength: 20,
    required: true,
  },
  model: {
    type: String,
    maxlength: 20,
    required: true,
  },
  year: {
    type: Number,
    max: new Date().getFullYear(),
    min: 1888,
    required: true,
  },
  kilometers: {
    type: Number,
    max: 999999,
    min: 0,
    required: true,
  },
  motor: {
    type: MotorSchema,
    required: true,
  },
  user: {
    type: String,
    maxlength: 30,
    required: true,
  },
});
const model = mongoose.model('Car', Car);
module.exports = model;
            </code></pre>
            <h4>Tokenin käsittely</h4>
            <pre><code>
                const jwt = require('jsonwebtoken');
require('dotenv').config();

// Funktio tokenin luomiseksi
exports.createToken = (user) => {
  // payloadissa talenttuu tokeniin haluttua tietoa.
  // Tieto voi periaatteessa olla mitä tahansa mutta yleensä siinä viedään
  // esimerkiksi käyttäjän nimi tai id
  const payload = {
    username: user.username,
    isadmin: user.isadmin,
  };
  // Token luodaan sign() metodilla onka argumenteiksi tulee payload sekä secret
  // Näistä encoodataan tokeni joka tallentuu client puolelle
  const token = jwt.sign(payload, process.env.SECRET, {
    expiresIn: '2h', // expiroituu 2 tunnissa
  });

  return token;
};
// Tokenin verifiointi
exports.verifyToken = (req, res, next) => {
  // Token saadaan joko pyynnön bodystä, headereista tai selaimen cookieista
  const token =
    req.body.token || req.headers['x-access-token'] || req.cookies.access_token;
  // Jos tokenia ei löydy heitetään virhe
  if (!token) {
    return res.status(403).send({
      success: false,
      message: 'No token',
    });
  } else {
    // Tokeni verifioidaan jsonwebtoken kirjaston verify() metodilla
    jwt.verify(token, process.env.SECRET, (error, decoded) => {
      if (error) {
        return res.status(400).json({
          success: false,
          message: 'Token is not valid or it is expired',
        });
      } else {
        // Tallennetaan purettu token pyynnön decoded muuttujaan myöhempää käyttöä varten
        req.decoded = decoded;
        next();
      }
    });
  }
};
            </code></pre>
      </div>

      <div class="project-card">
        <h3>Covid-19 app</h3>
        <p>Frontend perusteet kurssille tekemäni pieni sovellus josta pystyi hakemaan (api jota käytetty ei ole enää toiminnassa) eri maiden korona tapausten määrän ja ostamaan erilaisia tuotteita tartunta riskin vähentämiseksi.</p>
       <p>Sovelluksen github: <a href="https://github.com/KaitamakiKalle/felopputyo">https://github.com/KaitamakiKalle/felopputyo</a></p>
        <img src="./img/etusivu.png" alt="etusivu" class="feapp">
       <img src="./img/kauppasivu.png" alt="kauppa" class="feapp">
       <img src="./img/ostoskori.png" alt="ostoskori" class="feapp">
          </div>
    </div>
    </div>
    </div>

 
  </div>
  

</body>

</html>
