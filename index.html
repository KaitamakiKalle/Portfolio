<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="styles.css" />
    <link rel="stylesheet" type="text/css" href="prism.css" />
</head>
<body>
    <div class="container">
        <header>
            <h1>Portfolio</h1>
            <h2 style="margin-bottom: 0%; padding-bottom: 0%;">Kalle Kaitamäki</h2>
            <h3 style="margin-top: 0%;">aa3470@student.jamk.fi</h3>
        </header>

       
          <h2 style="padding-top: 1%;">REST-api:n kehitys</h2>
        <p>Olen opinnoissani keskittynyt varsinkin rest apien ohjelmointiin. Ohjelmoinnissa olen käyttänyt pääasiassa express.js kirjastoa</p>
        <p>Muunmuassa ticorporate projektissa olin ryhmämme backend-ohjelmoija ja tein rest apin DigiMajakka nimiselle sovelluksellemme.</p>
        <p>Esimerkit on otettu DigiMajakka projektin koodeista. Backendissä käytettiin express.js ja MySQL kirjastoja. Infrastruktuuri rakennettiin AWS:n palvelujen päälle.</p>
           <code class="language-typescript">
            import express from 'express';

            import cookieParser from 'cookie-parser';
            import cors from 'cors';
            import morgan from 'morgan';
            import ErrorHandler from './middlewares/error-handler';
            
            // Import routes from routes folder
            import indexRouter from './routes/index';
            import profileRouter from './routes/profiles';
            import joblistingRouter from './routes/joblisting';
            import userRouter from './routes/users';
            import imageRouter from './routes/images';
            import cityRouter from './routes/cities';
            import schoolRouter from './routes/schools';
            import linkRouter from './routes/links';
            import skillRouter from './routes/skills';
            
            // Usage of environment varaibles
            import dotenv from 'dotenv';
            dotenv.config();
            
            // Create express app
            const app = express();
            
            // Necessary middlewares
            app.use(express.json({limit: '50mb'}));
            app.use(express.urlencoded({extended: false, limit: '50mb'}));
            app.use(cookieParser());
            app.use(cors());
            app.use(morgan('common'));
            
            // Take routes in use
            app.use('/', indexRouter);
            app.use('/profiles', profileRouter);
            app.use('/joblistings', joblistingRouter);
            app.use('/users', userRouter);
            app.use('/images', imageRouter);
            app.use('/cities', cityRouter);
            app.use('/schools', schoolRouter);
            app.use('/links', linkRouter);
            app.use('/skills', skillRouter);
            
            // Take custom error handler in use
            app.use(ErrorHandler);
            export = app;
           </code>

 <p>Profiili reitin kontrolleri</p>
 <code class="language-typescript">
    import type express from 'express';
import queryDb from '../db-connection';
import * as validation from '../validators/validation';
import type Profile from '../models/profile-model';
import CustomError from '../custom-error';
import convertBodyToQueryFormat from '../functions/convert-body-to-update-string';
import type {IAuthenticatedRequest} from '../middlewares/auth';

const profileController = {
  // Function to return all profiles
  async findAll(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const data = await queryDb(
        'SELECT * FROM UserProfile WHERE public = true;',
        [],
      );
      console.log(data);

      response.status(200).json(data);
    } catch (error: unknown) {
      next(error);
    }
  },

  // Return one profile by specific id
  async findById(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const data = await queryDb(
        'SELECT * FROM UserProfile WHERE userprofileid = ?',
        [_request.params.profileid],
      );

      if (data.length <= 0) {
        throw new Error('No profile found with given id');
      }
      console.log(data);

      response.status(200).json(data);
    } catch (error: unknown) {
      next(error);
    }
  },

  // Insert new profile into database
  async createProfile(
    _request: IAuthenticatedRequest,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      if (typeof _request.user === 'undefined') {
        throw new Error('User does not exist');
      }

      // Find users data and citys name that users school is in
      const userdata = await queryDb(
        'SELECT UA.email, UA.School_name AS schoolname, SC.City_name AS cityname FROM UserAccount UA INNER JOIN SchoolCity SC ON SC.School_name=UA.School_name WHERE UA.email = ?;',
        [_request.user.email],
      );

      if (typeof userdata === 'undefined' || !userdata.length) {
        throw new Error('User does not exist');
      }

      // Take users data from array
      const user = userdata[0];

      // Check that user object has specified keys
      if ('email' in user && 'cityname' in user && 'schoolname' in user) {
        // Template profile with placeholder data which will be inserted into database
        const profile: Profile = {
          firstname: 'Etunimi',
          familyname: 'Sukunimi',
          phonenumber: 'Puhelinnumero',
          description: 'Kuvaus',
          lookingfor: 'Mitä etsit',
          studyfield: 'Koulutusala',
          yearofstudy: 1,
          publicity: false,
          picturelink: '',
          email: '',
          cityname: String(user.cityname),
          accountemail: String(user.email),
          schoolname: String(user.schoolname),
        };

        // Insert placeholder data to users profile
        const insertedProfile = await queryDb(
          'INSERT INTO UserProfile (firstname, familyname, phonenumber, aboutme, lookingfor, studyfield, yearofstudy, public, picturelink, email, City_name, UserAccount_email, UserAccount_School_name) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)',
          Object.values(profile),
        );

        console.log(insertedProfile);

        response.status(201).json({
          message: 'Profile created succesfully',
          success: true,
        });
      } else {
        throw new TypeError('Error when trying to create new profile');
      }
    } catch (error: unknown) {
      next(error);
    }
  },

  // Updates profile
  async updateProfile(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      // Check that phone number is in valid format if it is provided
      if (
        _request.body.phonenumber &&
        !validation.validatePhoneNumber(_request.body.phonenumber)
      ) {
        throw new CustomError('Phonenumber is not valid', 400);
      }
      // Check that email is in valid format if it is provided
      if (
        _request.body.email &&
        !validation.validateEmail(_request.body.email)
      ) {
        throw new CustomError('Email is not valid', 400);
      }

      // Convert request body to sql query and query parameters
      // Convert function is used here because fields that user wants to update is random
      // Because of this constant sql query cannot handle all requests
      const {sql, sqlparams} = convertBodyToQueryFormat(
        _request,
        'UserProfile',
        'userprofileid',
      );

      const update = await queryDb(sql, [
        ...sqlparams,
        _request.params.profileid,
      ]);

      console.log('Update succesfull');

      console.log(update);

      response.status(200).json({
        message: 'Updated profile succesfully',
        success: true,
      });
    } catch (error: unknown) {
      next(error);
    }
  },

  // Deletes profile by id
  async deleteProfile(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const result = await queryDb('CALL deleteProfile(?);', [
        _request.params.profileid,
      ]);

      console.log(result);

      response.status(200).json({
        message: 'Deleted profile succesfully',
        success: true,
      });
    } catch (error: unknown) {
      next(error);
    }
  },

  // Find profile by user email
  async findByEmail(
    _request: IAuthenticatedRequest,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      let userEmail = '';

      if (_request.user && typeof _request.user.email === 'string') {
        userEmail = _request.user.email;
      } else {
        throw new Error('Token is not valid or email not received in token');
      }

      const data = await queryDb(
        'SELECT * FROM UserProfile WHERE UserAccount_email = ?',
        [userEmail],
      );

      if (data.length <= 0) {
        throw new Error('No profile found with given email');
      }

      console.log(data);

      response.status(200).json(data);
    } catch (error: unknown) {
      next(error);
    }
  },
};
export default profileController;
 </code>
 <p>Profiili kontrollerissa käytetty funktio joka muuttaa http pyynnön mukana tulevan bodyn datan SQL kyselyksi. Funktio tarvittiin koska haluttiin että frontendistä ei tarvinnut lähettää kaikkia profiilin kenttiä tietoja päivittäessä backendille.</p>
           
 <code class="language-typescript">
    /* eslint-disable @typescript-eslint/comma-dangle */
import type express from 'express';

/**
 * Converts request body to sql query string ('') and parameter values ([values]) used in mysql.query(query, parameters) method
 * @param {express.Request} request express request
 * @param {string} tablename table in database which query will affect
 * @param {string} idcolumnname Primary keys name in that database table
 * @return {object} object which contains sql string and values in array used in mysql.query() function
 */

const convertBodyToQueryFormat = (
  request: express.Request,
  tablename: string,
  idcolumnname: string,
) => {
  if (!request.body) {
    throw new Error('No body received in request');
  }

  // Take values values from object to array
  const values: unknown[] = Object.values(request.body);
  // Take keys(columns) from object to array
  const keys = Object.keys(request.body);

  // Update string will contain update query
  // It is constructed from values and keys separated from object
  // This allows to use this route to update any number of columns in table row

  // Start string of the query
  let sql = 'UPDATE ' + tablename + ' SET ';
  // Add each of keys(column names) one by one into sql string
  for (const x of keys) {
    sql += String(x) + ' = ?';
    // If added last key then insert justimport process from 'node:process';
import {CognitoIdentityServiceProvider} from 'aws-sdk';
import type express from 'express';

// Cognito service
const identityServiceProvider = new CognitoIdentityServiceProvider({
  region: process.env.REGION,
});

// Type for user attribute. Used to extend request
export type IUser = {
  id: string | undefined;
  email: string | undefined;
};

// Extended Request type providing user attribute and authorization header
export type IAuthenticatedRequest = {
  user?: IUser;
  headers: {
    authorization?: string;
  };
} & express.Request;

/**
 * Checks that there is token and places users information from decoded token to requests user attribute
 * @param  {IAuthenticatedRequest} _request  express request
 * @param {express.Response} _response express response
 * @param {express.NextFunction} next express next function
 */
export const authHandler = async (
  _request: IAuthenticatedRequest,
  _response: express.Response,
  next: express.NextFunction,
) => {
  try {
    // Check that there is authorization header
    if (_request.headers.authorization) {
      const token = _request.headers.authorization;

      // Get raw user data from token
      const rawUser = await identityServiceProvider
        .getUser({AccessToken: token})
        .promise();

      // Place cognito id and email to requests user attribute
      _request.user = {
        id: rawUser.UserAttributes.find((attr) => attr.Name === 'sub')?.Value,
        email: rawUser.UserAttributes.find((attr) => attr.Name === 'email')
          ?.Value,
      };
      // Move to next middleware
      next();
    } else {
      throw new Error('No authorization header received');
    }
  } catch (error: unknown) {
    next(error);
  }
}; empty ' ' otherwise ',' is needed
    sql += keys.indexOf(x) === keys.length - 1 ? ' ' : ', ';
  }

  // Last part of update string where you specify profile id
  sql += 'WHERE ' + idcolumnname + ' = ?;';

  return {
    sql: sql,
    sqlparams: values,
  };
};

export default convertBodyToQueryFormat;
 </code>
 <p>Syötteitä validoitiin projektissa esimerkiksi factory functioiden avulla.</p>

 <code class="language-typescript">
    // Factory function is used to make sure there are no unwanted fields in object which contains new advert.
// Factory function also places default values into object keys if no value is given.
const jobadvertFactor = ({
  advertid = '',
  firstname = '',
  familyname = '',
  company = null,
  startdate = null,
  email = 'esimerkki@sahkoposti.com',
  phonenumber = '000-0000-0000',
  jobtitle = '',
  description = '',
  salary = '',
  validuntil = '0000-00-00',
  isvalid = true,
  accepted = false,
  city = '',
}: Jobadvert): Jobadvert => ({
  advertid,
  firstname,
  familyname,
  company,
  startdate,
  email,
  phonenumber,
  jobtitle,
  description,
  salary,
  validuntil,
  isvalid,
  accepted,
  city,
});
 </code>
 
 <h2>Tietokannat</h2>
            <p>Tietokannoista minulta löytyy osaamista SQL kielestä sekä MongoDB:stä.</p>
            <p>DigiMajakka projektissa tein esimerkiksi proceduureja ja eventtejä tietokantaamme. SQL lauseita esittelin jo aikaisemmassa kontrollerin koodissa.</p>
            <div class="smallimg">
                <img src="./img/sqlevent.png" alt="sql-event">
              </div>
             
            <div class="smallimg">
                <img src="./img/proceduuri.png" alt="proceduuri">
              </div>
              <p>Lisäksi suunnittelin projektissa tietokannan rakennetta. Esimerkkinä tietokannan ER-malli.</p>
              <img class="image" src="./img/er-malli.png" alt="er-malli">
       
       
            
        <p>MongoDB:stä esimerkkinä backend 1 kurssin lopputyöstä otettua koodia jossa käytetty mongoose kirjastoa.</p>
            <code class="language-javascript">
                const mongoose = require('mongoose');
const Schema = mongoose.Schema;
const MotorSchema = require('./Motor');
const Car = new Schema({
  license: {
    type: String,
    maxlength: 7,
    match: /[A-Z]{3}-[0-9]{3}/,
    minlength: 7,
    unique: true,
    required: true,
  },
  brand: {
    type: String,
    maxlength: 20,
    required: true,
  },
  model: {
    type: String,
    maxlength: 20,
    required: true,
  },
  year: {
    type: Number,
    max: new Date().getFullYear(),
    min: 1888,
    required: true,
  },
  kilometers: {
    type: Number,
    max: 999999,
    min: 0,
    required: true,
  },
  motor: {
    type: MotorSchema,
    required: true,
  },
  user: {
    type: String,
    maxlength: 30,
    required: true,
  },
});
const model = mongoose.model('Car', Car);
module.exports = model;
            </code>
            <code class="language-javascript">const Car = require('../models/Car');
                const User = require('../models/User');
                
                // Kaikkien autojen haku
                exports.findAll = (req, res) => {
                  Car.find()
                    .then((response) => {
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(400).send({
                        message: 'Error occured',
                        error: error,
                      });
                    });
                };
                
                // Auton haku id:n perusteella
                exports.findByID = (req, res) => {
                  Car.find({ _id: req.params.id })
                    .then((response) => {
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(400).send({
                        message: 'Error occured',
                        error: error,
                      });
                    });
                };
                
                // Auton haku rekisterinumeron perusteella
                exports.findByLicense = (req, res) => {
                  Car.find({ license: req.params.license })
                    .then((response) => {
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(400).send({
                        message: 'Error occured',
                        error: error,
                      });
                    });
                };
                
                // Auton lisäys kantaan
                exports.add = (req, res) => {
                  // Sijoitetaan käyttäjänimi pyynnön bodyyn
                  req.body.user = req.decoded.username;
                  // lisättävän auton tiedot tulevat pyynnön bodyssä
                  Car.create(req.body)
                    .then((response) => {
                      // kun käyttäjälle lisätään auto myös hänen autojen määrää on lisättävä yhdellä
                      User.updateOne(
                        { username: req.decoded.username },
                        { $inc: { numOfCars: 1 } }
                      ).then((response) => {
                        console.log(response);
                      });
                      console.log('Document added succesfully');
                      res.status(201).json(response);
                    })
                    .catch((error) => {
                      res.status(error.status || 400).send({
                        message: 'Error when posting data',
                        error: error,
                      });
                    });
                };
                
                // Auton poisto kannasta id:n perusteella
                exports.delByID = (req, res) => {
                  Car.findOneAndDelete({ _id: req.params.id })
                    .then((response) => {
                      User.updateOne(
                        { username: response.user },
                        { $inc: { numOfCars: -1 } }
                      ).then((response) => {
                        console.log(response);
                      });
                      console.log(`Deleted car with license:${response.license} succesfully`);
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(error.status || 400).send({
                        message: 'Error when deleting data',
                        error: error,
                      });
                    });
                };
                
                // Auton poisto rekisterinumeron perusteella
                exports.del = (req, res) => {
                  Car.findOneAndDelete({ license: req.params.license })
                    .then((response) => {
                      User.updateOne(
                        { username: response.user },
                        { $inc: { numOfCars: -1 } }
                      ).then((response) => {
                        console.log(response);
                      });
                      console.log(`Deleted car with license:${response.license} succesfully`);
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(error.status || 400).send({
                        message: 'Error when deleting data',
                        error: error,
                      });
                    });
                };
                
                // Pyynnön ensimmäinen parametri kertoo päivitettävän auton rekisterinumeron
                // Toinen parametri kertoo tiedon joka halutaan päivittää
                // Kolmas parametri kertoo päivitetyn arvon valitulle tiedolle
                exports.updateByIDParams = (req, res) => {
                  Car.updateOne(
                    { _id: req.params.id },
                    { 'req.params.field': req.params.value }
                  )
                    .then((response) => {
                      console.log('Update succesfull');
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(400).send({
                        message: 'Update failed',
                        error: error,
                      });
                    });
                };
                
                // Autojen tietojen päivitys id:n perusteella
                exports.updateByID = (req, res) => {
                  Car.updateOne({ _id: req.params.id }, req.body)
                    .then((response) => {
                      // Tarkistetaan että käyttäjä joka yrittää muokata auton tietoja on auton omistaja tai admin
                
                      console.log('Update succesfull');
                      res.status(201).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(error.status || 400).send({
                        message: 'Error when updating data',
                        error: error,
                      });
                    });
                };
                
                // Autojen tietojen päivitys rekisterinumeron perusteella
                exports.updateByLicense = (req, res) => {
                  Car.updateOne({ license: req.params.license }, req.body)
                    .then((response) => {
                      // Tarkistetaan että käyttäjä joka yrittää muokata auton tietoja on auton omistaja tai admin
                
                      console.log('Update succesfull');
                      res.status(201).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(error.status || 400).send({
                        message: 'Error when updating data',
                        error: error,
                      });
                    });
                };
                
                // Auton haku käyttäjänimen perusteella
                exports.findByOwner = (req, res) => {
                  Car.find({ user: req.params.user })
                    .then((response) => {
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(error.status || 400).send({
                        message: 'Error when finding data',
                        error: error,
                      });
                    });
                };
                
                // Autojen haku vuosimallin perusteella
                exports.findByYear = (req, res) => {
                  Car.find({ year: req.params.year })
                    .then((response) => {
                      console.log('Find succesfull');
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(400).send({
                        message: error.message,
                        error: error,
                      });
                    });
                };
                
                // Autojen haku vuosimallin perusteella tietyltä vuosi väliltä
                exports.findBetweenYear = (req, res) => {
                  Car.find({ year: { $gte: req.params.min, $lte: req.params.max } })
                    .then((response) => {
                      console.log('Find succesfull');
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(400).send({
                        message: error.message,
                        error: error,
                      });
                    });
                };
                
                // Haku moottorin koon perusteella
                exports.findByDisplacement = (req, res) => {
                  Car.find({
                    'motor.displacement': req.params.displacement,
                  })
                
                    .then((response) => {
                      console.log('Find succesfull');
                      res.status(200).json(response);
                    })
                    .catch((error) => {
                      console.error(error);
                      res.status(400).send({
                        message: error.message,
                        error: error,
                      });
                    });
                };</code>

            <p>Backendin arkkitehtuuri koostuu pääasiassa kontrollolereista ja routereista. Alla esimerkkinä kontrolleri ja router, josta löytyy toiminnot koulujen hakemiseen.</p>
            
            <h2>AWS</h2>
            <p>DigiMajakka sovellus toteutettiin seuraavanlaisessa ympäristössä joka oli rakennettu aws palveluita käyttäen.</p>
            <div class="smallimg">
                <img src="./img/aws.png" alt="aws-arkkitehtuuri" class="smallimg">
              </div>
              <p>Koodista aws palveluihin saatiin yhteys aws-sdk kirjaston avulla. Esimerkkinä käyttäjänhallintaa varten toteutettu luokka.</p>
              <code class="language-typescript">import process from 'node:process';
                import dotenv from 'dotenv';
                import {CognitoIdentityServiceProvider} from 'aws-sdk';
                dotenv.config();
                import {
                  AuthenticationDetails,
                  CognitoUser,
                  CognitoUserAttribute,
                  CognitoUserPool,
                } from 'amazon-cognito-identity-js';
                
                class CognitoHelper {
                  public userPool: CognitoUserPool;
                  public cognitoIdentity: CognitoIdentityServiceProvider;
                
                  constructor() {
                    this.userPool = new CognitoUserPool({
                      UserPoolId: process.env.USER_POOL_ID ?? '',
                      ClientId: process.env.CLIENT_ID ?? '',
                    });
                    this.cognitoIdentity = new CognitoIdentityServiceProvider({
                      accessKeyId: process.env.COGNITO_ACCESS_KEY,
                      secretAccessKey: process.env.COGNITO_SECRET_KEY,
                      region: process.env.REGION,
                    });
                  }
                
                  /**
                   * Method that signs new user to cognito and database
                   * @param {string} email users email
                   * @param {string} password users password
                   * @return {Promise} resolved promise
                   */
                  async signUp(email: string, password: string) {
                    return new Promise((resolve, reject) => {
                      const attributeList: CognitoUserAttribute[] = [
                        new CognitoUserAttribute({
                
                          Name: 'email',
                          Value: email,
                        }),
                      ];
                
                      // Signup user to cognito
                      this.userPool.signUp(
                        email,
                        password,
                        attributeList,
                        [],
                        (error, result) => {
                          if (error) {
                            reject(error);
                          }
                
                          // If signup was succesfull return username
                          resolve(result?.user.getUsername());
                        },
                      );
                    });
                  }
                
                  /**
                   * Method that confirms user registration with code that cognito sent via email
                   * @param {string} email users email
                   * @param {string} code users confirmation code received via email
                   * @return {Promise} resolved promise
                   */
                  async confirmSignUp(email: string, code: string) {
                    // Create new instance of CognitoUser
                    return new Promise((resolve, reject) => {
                      const cognitoUser = new CognitoUser({
                        Username: email,
                        Pool: this.userPool,
                      });
                
                      // Use cognitoUser class method to verify confirmation code
                      cognitoUser.confirmRegistration(code, true, (error, result) => {
                        if (error) {
                          reject(error);
                        }
                
                        resolve(JSON.stringify(result));
                      });
                    });
                  }
                
                  /**
                   * Method to resend confirmation code to user
                   * @param {string} email users email
                   * @return {promise} resolved promise
                   */
                  async resendConfirmCode(email: string) {
                    // Create new instance of CognitoUser
                
                    return new Promise((resolve, reject) => {
                      const cognitoUser = new CognitoUser({
                        Username: email,
                        Pool: this.userPool,
                      });
                
                      // Use class method to resend confirmation code
                      cognitoUser.resendConfirmationCode((error, result) => {
                        if (error) {
                          reject(error);
                        }
                
                        resolve(JSON.stringify(result));
                      });
                    });
                  }
                
                  /**
                   * Method to sign user in
                   * @param {string} email users registered email
                   * @param {string} password users password
                   * @return {Promise} resolved promise
                   */
                  async signIn(email: string, password: string) {
                    return new Promise((resolve, reject) => {
                      const cognitoUser = new CognitoUser({
                        Username: email,
                        Pool: this.userPool,
                      });
                
                      const authenticationDetails = new AuthenticationDetails({
                        Username: email,
                        Password: password,
                      });
                
                      this.cognitoIdentity.adminGetUser(
                        {
                          UserPoolId: process.env.USER_POOL_ID || '',
                          Username: email || '',
                        },
                        (error) => {
                          if (error) reject(error); // an error occurred
                        },
                      );
                
                      cognitoUser.authenticateUser(authenticationDetails, {
                        // If sign in was success check if user has confirmed their account with code
                        onSuccess(session, userConfirmationNecessary) {
                          if (userConfirmationNecessary) {
                            resolve({userConfirmationNecessary});
                          }
                
                          // In case of everything is ok send token of signed in user forward
                
                          resolve({
                            accessToken: session.getAccessToken().getJwtToken(),
                          });
                        },
                        onFailure(error) {
                          reject(error);
                        },
                      });
                    });
                  }
                
                  /**
                   * Method that signs user out
                   * @param {string} email users email
                   * @return {Promise} resolved promise
                   */
                  async signOut(email: string) {
                    return new Promise((resolve) => {
                      const cognitoUser = new CognitoUser({
                        Username: email,
                        Pool: this.userPool,
                      });
                
                      cognitoUser.signOut(() => {
                        resolve('Signed out successfully');
                      });
                    });
                  }
                
                  /**
                   * Method to for authenticated user to delete their account/data from cognito and database
                   * @param {string} email users email
                   * @param {string} password users password fro authentication
                   * @return {Promise} promise
                   */
                  async deleteUser(email: string, password: string) {
                    return new Promise((resolve, reject) => {
                      // Create new instance of cognitoUser
                      const cognitoUser = new CognitoUser({
                        Username: email,
                        Pool: this.userPool,
                      });
                      // Details for authentication
                      const authenticationDetails = new AuthenticationDetails({
                        Username: email,
                        Password: password,
                      });
                
                      // Try to authenticate user
                      cognitoUser.authenticateUser(authenticationDetails, {
                        // If sign in was success check if user has confirmed their account with code
                        onSuccess(_session, userConfirmationNecessary) {
                          if (userConfirmationNecessary) {
                            resolve({userConfirmationNecessary});
                          }
                
                          // On successfull login delete user
                          cognitoUser.deleteUser((error, result) => {
                            if (error) {
                              reject(error);
                            }
                
                            console.log(result);
                
                            resolve(result);
                          });
                        },
                        onFailure(error) {
                          reject(error);
                        },
                      });
                    });
                  }
                
                  /**
                   * Method to start password reset workflow. This will send email with confirmation code to user
                   * @param {string} email users email
                   * @return {Promise} promise
                   */
                  async resetPassword(email: string) {
                    return new Promise((resolve, reject) => {
                      const cognitoUser = new CognitoUser({
                        Username: email,
                        Pool: this.userPool,
                      });
                
                      this.cognitoIdentity.adminGetUser(
                        {
                          UserPoolId: process.env.USER_POOL_ID || '',
                          Username: email || '',
                        },
                        (error) => {
                          if (error) reject(error); // an error occurred
                        },
                      );
                
                      cognitoUser.forgotPassword({
                        onSuccess: function (result) {
                          console.log('call result: ' + result);
                          resolve(result);
                        },
                        onFailure: function (error) {
                          reject(error);
                        },
                      });
                    });
                  }
                
                  /**
                   * Method to complete password reset request
                   * @param {string} email users email
                   * @param {string} confirmationCode password reset confirmation code received via email
                   * @param {string} newPassword new password provided by user
                   * @return promise
                   */
                  async confirmPassword(
                    email: string,
                    confirmationCode: string,
                    newPassword: string,
                  ) {
                    return new Promise((resolve, reject) => {
                      const cognitoUser = new CognitoUser({
                        Username: email,
                        Pool: this.userPool,
                      });
                      cognitoUser.confirmPassword(confirmationCode, newPassword, {
                        onFailure(error) {
                          reject(error);
                        },
                        onSuccess() {
                          resolve('Password reset success');
                        },
                      });
                    });
                  }
                }
                
                export default CognitoHelper;</code>

                <h2>Tekoäly/koneoppiminen</h2>
                <p>Olen käynyt kursseja tekoälyn kehittämiseen liittyen ja esimerkiksi tähän olen valinnut tekemäni lopputyön. Kyseessä on tensorflow.js kirjastolla toeteutettu neuroverkko joka tunnistaa kuvasta onko ihmisellä kasvomaski naamalla vai ei.</p>
            <code class="language-javascript">const tf = require('@tensorflow/tfjs-node');
                const fs = require('fs');
                const path = require('path');
                // Funktio saa parametrina kansion osoitteen jossa kuvat ovat ja labelin joka kyseisille kuville annetaan
                // Kuvat otetaan kansiosta ja muutetaan tensoreiksi jonka jälkeen niistä tehdään objekteja
                // objetkit sisältävät kuva tensorin ja sitä vastaavan label arvon eli muoto on {xs, ys}
                // Funktio toimii vain kun kyseessä on kuvien luokittelu koska parametrinä määritelty label annetaan kaikille
                // kansiossa oleville kuville (esim. 0 tai 1)
                async function imgsToObjArr(imgArrSrc = '', label) {
                  // Objektit tallennetaan arr taulukkoon
                  const arr = [];
                  // Haetaan kaikki tiedostonimet readdirSync metodilla
                  const filenames = await fs.readdirSync(imgArrSrc);
                
                  // Jokainen tiedosto käydään erikseen lävitse
                  await filenames.forEach((file) => {
                    // tarkistetaan että tiedoston pääte on jpg tai jpeg jotta mahdolliset virheelliset tiedostot saadaa
                    // karsittua pois
                    if (path.extname(file) == '.jpg' || path.extname(file) == '.jpeg') {
                      // koska kansion tiedostojen nimet ovat sring muodossa filenames taulukossa saadaan kansiopolusta ja
                      // filenames taulukon alkiosta yksittäisen kuvan osoite readFileSync metodille
                      const img = fs.readFileSync(`${imgArrSrc}/${file}`);
                
                      // Kun kuva on haettu img muuttujaan se muutetaan tensoriksi tensorflown decodeImage metodilla
                      const imgtensor = tf.node.decodeImage(img, 3);
                
                      // Kuvat ovat yleensä valtavan kokoisia ja maskin tunnistamiseen kuvasta ei todellakaan tarvita
                      // kovinkaan tarkkaa kuvaa joten kuvat pienennetään 64x64 pikselin kokoisiksi
                      const imgResized = tf.image.resizeBilinear(imgtensor, [64, 64]);
                
                      // lisätään kuva parametrina annetun labelin kanssa palautettavaan taulukkoon
                      arr.push({ img: imgResized, label: label });
                    }
                  });
                
                  return arr;
                }
                
                // Funktio erottaa xs ja ys arvot omiin taulukkoihinsa objekti taulukosta
                function getValsFromObjArr(objArr) {
                  // otetaan xs arvot mapilla omaan taulukkoonsa
                  const xsArr = objArr.map((elem) => {
                    return elem.img;
                  });
                  // otetaan ys arvot mapilla omaan taulukkoonsa ja muutetaan ne onehot muotoon
                  const ysArr = objArr.map((elem) => {
                    return elem.label === 1 ? [1, 0] : [0, 1];
                    // return elem.label;
                  });
                  return {
                    xsArr,
                    ysArr,
                  };
                }
                
                // Funktio normalisoi tensorin
                // Funktiolle voidaan syöttää minimi ja maksimi arvot jolloin se käyttää niitä eikä laske arvoja
                // syötetystä tensorista
                // Jos arvoja ei anneta ne lasketaan tensorista ja myös palautetaan myöhempää käyttöä varten
                async function normalize(tensor, maxVal, minVal) {
                  // Jos min ja max arvot on annettu käytetään niitä
                  if (maxVal && minVal) {
                    const max = maxVal;
                    const min = minVal;
                    return tensor.sub(min).div(max.sub(min));
                  } else {
                    // muulloin ne lasketaan syötetystä tensorista
                    const max = tf.max(tensor);
                    const min = tf.min(tensor);
                    // Tällöin palautuu objekti joka sisältää normalisoidun tensorin ja min sekä max arvot
                    return { normlizedTensor: tensor.sub(min).div(max.sub(min)), min, max };
                  }
                }
                
                // createModel luo modelin
                // Koska kyseessä on kuvanluokittelu tehtävä käytetään convolutionaalista neuroverkkoa
                /*
                Verkon rakenne on:
                
                convolutional layer(relu) + Maxpooling layer
                convolutional layer(relu) + Maxpooling layer
                convolutional layer(relu) + Maxpooling layer
                flatten layer
                dense layer(relu)
                dense layer(relu)
                dense layer(softmax) eli output
                
                */
                
                // Funktio jolla voidaan erottaa taulukosta haluttu määrä testi dataa
                // parametrina annetava taulukko josta data halutaan erottaa mutatoidaan tarkoituksella ettei
                // testidata sekoitu harjoitusdataan
                function separateTestData(amount, arr) {
                  // Leikataan splicella taulukosta haluttu määrä testidataa
                  const testArr = arr.splice(
                    arr.length * (1 - amount),
                    arr.length - arr.length * amount
                  );
                  return testArr;
                }
                
                function createModel() {
                  const model = tf.sequential();
                  // Convolutionaalinen layer
                  model.add(
                    tf.layers.conv2d({
                      filters: 16,
                      kernelSize: [3, 3],
                      activation: 'relu',
                      inputShape: [64, 64, 3],
                    })
                  );
                  // pooling layer
                  model.add(tf.layers.maxPooling2d([4, 4]));
                  model.add(
                    tf.layers.conv2d({
                      filters: 8,
                      kernelSize: [3, 3],
                      activation: 'relu',
                    })
                  );
                
                  model.add(tf.layers.maxPooling2d([2, 2]));
                  model.add(
                    tf.layers.conv2d({
                      filters: 2,
                      kernelSize: [3, 3],
                      activation: 'relu',
                    })
                  );
                  model.add(tf.layers.maxPooling2d([1, 1]));
                  model.add(tf.layers.flatten());
                  model.add(tf.layers.dense({ units: 10, activation: 'relu' }));
                  model.add(tf.layers.dense({ units: 5, activation: 'relu' }));
                  model.add(tf.layers.dense({ units: 2, activation: 'softmax' }));
                
                  // Modelin kääntäminen
                  model.compile({
                    optimizer: tf.train.adam(0.01),
                    // Koska kyseessä on kuvanluokittelu jossa output on muodossa [0,1] eli sisältää kaksi todennäköisyyttä
                    // käytetään categoricalCrossentropy loss funktiota
                    loss: 'categoricalCrossentropy',
                    metrics: ['accuracy'],
                  });
                  return model;
                }
                
                async function run() {
                  // haetaan kuvat ja labelit
                
                  // Maskittomien kuvat sijaitsevat './0' kansiossa ja maskillisten kuvat './1' kansiossa
                
                  // Maskittomien kuvat
                  const imagesObj0 = await imgsToObjArr('./0', 0);
                
                  // Maskillisten kuvat
                  const imagesObj1 = await imgsToObjArr('./1', 1);
                
                  // yhdistetään taulukot myöhempää käsittelyä varten
                  const imagesObjmerged = imagesObj0.concat(imagesObj1);
                
                  // Koska data on tällä hetkellä järjestetty niin että maskittomien kuvat ovat peräkkäin ennen maskillisten kuvia
                  // pitää data sekoittaa että neuroverkko saa kumpiakin kuvia harjoittaessa satunnaisessa järjestyksessä
                  // Sekoitetaan tensorflown shuffle() metodilla
                  tf.util.shuffle(imagesObjmerged);
                
                  // Muutetaan {kuva, label} objektejen kuvat ja labelit omiksi taulukoikseen
                  // Tuloksena on siis xs taulukko ja ys taulukko
                  const { xsArr, ysArr } = await getValsFromObjArr(imagesObjmerged);
                
                  // Kuinka paljon testidataa halutaan erottaa 0.1 = 10%
                  const testAmount = 0.1;
                
                  // Erotetaan splicella xs taulukosta haluttu määrä testidataa
                  const testXsArr = separateTestData(testAmount, xsArr);
                  // Erotetaan splicella ys taulukosta haluttu määrä testidataa
                  const testYsArr = separateTestData(testAmount, ysArr);
                
                  // Taulukot muunnetaan tensoreiksi
                
                  // koska xsArr taulukko sisältää tensoreita muutetaan se tensoriksi käyttämällä tensorflown
                  // stack() metodia. Metodi muuttaa juurikin tensoreita sisältävän taulukon tensoriksi
                  const xsTensorUnNlized = tf.stack(xsArr);
                
                  // xs tensori pitää vielä normalisoida
                  // koska max ja min arvoja tarvitaan vielä myöhemmin ne otetaan myös talteen
                  // muuttujiin max ja min
                  const {
                    normlizedTensor: xsTensor,
                    max,
                    min,
                  } = await normalize(xsTensorUnNlized);
                
                  // muutetaan ys taulukko tensoriksi
                  const ysTensor = await tf.tensor(ysArr);
                
                  // Koska haluamme käyttää min ja max arvoja myöhemmin valmiin tallennetun modelin kanssa
                  // Tallennetaan ne tekstitiedostoon
                  console.log(max);
                  const maxData = `${max.dataSync()}`;
                  const minData = `${min.dataSync()}`;
                  fs.writeFileSync('./min_max_vals/max.txt', maxData);
                  fs.writeFileSync('./min_max_vals/min.txt', minData);
                
                  // Luodaan model
                  const model = await createModel();
                
                  // Harjoitetaan model harjoitusdatalla
                  await model.fit(xsTensor, ysTensor, {
                    epochs: 50,
                    // Validationsplit ottaa annetun määrän harjoitusdataa joka kierroksella ja validoi kierroksen tulosta
                    // jo harjoittaessa
                    validationSplit: 0.1,
                    callbacks: {
                      // Seurataan lossia harjoituksen ajan console.log:lla  epoch ja loss
                      onEpochEnd: async (epoch, logs) => {
                        console.log('Epoch: ' + epoch + ' Loss: ' + logs.loss);
                      },
                    },
                  });
                
                  // Tehdään testi xs arvoista tensori ja normalisoidaan sen arvot. Huomaa että tässä käytetään
                  // jo tiedettyjä min ja max arvoja
                  const testTensorXS = await normalize(tf.stack(testXsArr), max, min);
                
                  // Tehdään test ys arvoista tensori
                  const testTensorYS = tf.tensor(testYsArr);
                
                  // Evaluoidaan modeli testidatalla
                  const result = await model.evaluate(testTensorXS, testTensorYS, {
                    batchSize: 32,
                  });
                
                  console.log('loss');
                  // evaluoinnin loss
                  result[0].print();
                  console.log('accuracy');
                  // evaluoinnin accuracy
                  result[1].print();
                
                  // Testataan modelia vielä omalla oikealla kuvalla
                  // haetaan kuva readFileSync metodilla
                  const testImage = await fs.readFileSync('./testImages/test1.jpg');
                  // Muutetaan kuva tensoriksi decodeImage metodilla
                  let testImgTensor = await tf.node.decodeImage(testImage, 3);
                  // Muutetaan kuva oikeaan kokoon
                  testImgTensor = await tf.image.resizeBilinear(testImgTensor, [64, 64]);
                  // Normalisoidaan tensori
                  testImgTensor.print();
                  testImgTensor = await normalize(testImgTensor, max, min);
                
                  // Laajennetaan testi tensorin ulottovuutta jotta muoto on sopiva inputille
                  testImgTensor = testImgTensor.expandDims(0);
                
                  // suoritetaan ennustus
                  const prediction = model.predict(testImgTensor);
                  // tulostetaan ennustus
                  prediction.print();
                  // ennustuksen ensimmäinen alkio kertoo millä todennäköisyydellä kuvan henkilöllä on maski naamalla
                  console.log(prediction.dataSync()[0]);
                
                  // Tallennetaan modeli
                  // Kommentoitu pois koska hyvä modeli on jo tallennettuna
                  // const saveResult = await model.save(
                  //   'file:////Users/kallekaitamaki/Documents/imageClassificator/faceMaskClassifier'
                  // );
                }
                
                run();</code>
            
                <div class="backend-grid">
              <div class="code">
            <pre>
                <code class="language-typescript">
const schoolC = {
  // Function for finding school by name
  async findByName(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const data = await queryDb('SELECT * FROM School WHERE name = ?;', [
        _request.params.name,
      ]);

      console.log(data);

      response.status(200).json(data);
    } catch (error: unknown) {
      next(error);
    }
  },
  // Function for finding all schools
  async findAll(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const data = await queryDb('SELECT * FROM School;', []);

      console.log(data);

      response.status(200).json(data);
    } catch (error: unknown) {
      next(error);
    }
  },
};
                </code>
            </pre>
          </div>
          <div class="code">
            <pre>
                <code class="language-typescript">
const schoolRouter = express.Router();

// Route to get school by name
// /schools/:name
schoolRouter.get('/:name', schoolC.findByName);

// Route to get all schools
// /schools/
schoolRouter.get('/', schoolC.findAll);
                </code>
            </pre>
          </div>
        </div>
    <p>Alla piilossa monimutkaisempi työilmoitusten hallintaan tehty kontrolleri. Valitsin tämän näytteeksi siksi, koska se on toteutettu pääosin hyvin mutta kehitättävääkin löytyisi vielä. Kontrollerista löytyy kaikki tarvittavat crud-toiminnot ja koodi on pääosin selkeää. Parannettavaa olisi työilmoituksen tallentavassa funktiossa. Funktiossa pitäisi ensinnäkin tarkistaa löytyykö syötettyä kaupunkia tietokannastamme koska muuten tietokanta kaatuu jos kaupunkia ei ole olemassa. Toiseksi päivämäärän käsittelyn olisi hyvin voinut tehdä funktioksi erilliseen tiedostoon, jotta koodi olisi ollut selkeämpää.</p>
        <details>
          <summary>Koodi avautuu tästä</summary>
          <div class="code">
            <pre>
              <code class="language-typescript">
const joblistingC = {
  // Return all job adverts from database
  async findAll(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const data = await queryDb('SELECT * FROM JobAdvert;', []);

      console.log(data);

      response.status(200).json(data);
    } catch (error: unknown) {
      next(error);
    }
  },
  // Function to find job advert by id
  async findById(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const data = await queryDb(
        'SELECT * FROM JobAdvert WHERE advertid = ?;',
        [_request.params.advertid],
      );

      console.log(data);

      response.status(200).json(data);
    } catch (error: unknown) {
      next(error);
    }
  },
  // Function to insert new advert into database
  async createAdvert(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      // Create unique id for advert
      const advertid: string = uniqid();

      // Create new date object
      const date = new Date();

      // Set date 6 months forward
      date.setMonth(date.getMonth() + 6);

      // Check that date is in correct format (YYYY-MM-DD)
      if (!_request.body.validuntil.match(/^\d{4}-\d{2}-\d{2}$/)) {
        throw new Error('Date is not in valid format. Should be YYYY-MM-DD.');
      }

      const userDate = new Date(_request.body.validuntil);
      // Check that adverts expiration date is less than half year from now
      const validuntil =
        userDate > date
          ? `${date.getFullYear()}-${
              // If month is below 10 it is needed to place 0 before month number so it is in valid format
              // Also getMonth start counting months from 0 (january) so it is needed to + 1 to get correct date
              date.getMonth() + 1 > 9
                ? date.getMonth() + 1
                : '0' + (date.getMonth() + 1)
            }-${
              // If day is below 10 it is needed 0 before day number so it is in valid format
              date.getDate() > 9 ? date.getDate() : '0' + date.getDate()
            }`
          : _request.body.validuntil;

      // Contruct advert object containing all necessary data
      const advertObj = {
        advertid,
        ..._request.body,
        accepted: false,
        isvalid: true,
        validuntil,
      };

      // Validate jobadvert
      const valid = jobadvertValidation(advertObj);

      // If advert is not valid throw error
      if (valid.valid && valid.jobadvert) {
        const insert = queryDb(
          'INSERT INTO JobAdvert VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?);',
          Object.values(valid.jobadvert),
        );

        // Email text
        const htmlText = `&lt;head&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;h2&gt;Ilmoituksen tunniste: ${advertid}&lt;h2&gt;
            &lt;h2&gt;${_request.body.jobtitle}&lt;/h2&gt;
            &lt;p&gt;Etunimi: ${_request.body.firstname}&lt;/p&gt;
            &lt;p&gt;Sukunimi: ${_request.body.familyname}&lt;/p&gt;
            &lt;p&gt;Yritys: ${
              _request.body.company === null ? '' : _request.body.company
            }&lt;/p&gt;
            &lt;p&gt; Alkamispäivä: ${
              _request.body.startdate === null ? '' : _request.body.startdate
            }&lt;/p&gt;
            &lt;p&gt;Sähköposti: ${_request.body.email}&lt;/p&gt;
            &lt;p&gt;Puhelinnumero: ${_request.body.phonenumber}&lt;/p&gt;
            &lt;p&gt;Kuvaus: ${_request.body.description}&lt;/p&gt;
            &lt;p&gt;Palkka: ${_request.body.salary}&lt;/p&gt;
            &lt;p&gt;Paikkakunta: ${_request.body.city}&lt;/p&gt;
            &lt;p&gt;Ilmoitus voimassa: ${validuntil}&lt;/p&gt;
            &lt;h3&gt;Poista ilmoitus painamalla alla olevaa linkkiä&lt;/h3&gt;
            &lt;a href="http://localhost:4200/jobadvert/delete/${advertid}"&gt;Poista ilmoitus&lt;/a&gt;
            &lt;/body&gt;`;

        // Send email to job adverts creator with link to update advert
        // Currently sends email only to digimajakka email because aws SES access rights are limited
        await ses.sendEmail(
          'digimajakka.asiakaspalvelu@gmail.com',

          'Kiitos luomastasi ilmoituksesta',
          htmlText,
        );

        console.log(insert);

        response.status(201).json({
          message: 'Created advert successfully',
          success: true,
          advert: {
            advertid,
            ..._request.body,
            validuntil,
          },
        });
      } else {
        // Create error object containing information which data received was incorrect
        const errorMsg = {
          message:
            'Some received fields not valid, shows false at invalid fields',
          phonenumber: valid.phonenumberValid,
          email: valid.emailValid,
          fieldtypes: valid.typeCheck,
          startdate: valid.startdateValid,
          expirationDate: valid.expirationDateValid,
        };
        throw new CustomError(JSON.stringify(errorMsg), 400);
      }
    } catch (error: unknown) {
      next(error);
    }
  },
  // Function to delete advert from database
  async deleteAdvert(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const result = await queryDb(
        'DELETE FROM JobAdvert WHERE advertid = ?;',
        [_request.params.advertid],
      );

      // Email text
      const htmltext =
        '&lt;h3&gt;Ilmoituksesi on poistettu palvelusta digimajakka&lt;/h3&gt;';

      // Send email to given email adress
      await ses.sendEmail(
        'digimajakka.asiakaspalvelu@gmail.com',

        'Ilmoituksen poisto',
        htmltext,
      );

      console.log(result);

      response.status(200).json({
        success: true,
        message: 'Deleted job advert successfully',
      });
    } catch (error: unknown) {
      next(error);
    }
  },
  // Function to update job advert
  async updateAdvert(
    _request: express.Request,
    response: express.Response,
    next: express.NextFunction,
  ) {
    try {
      const {sql, sqlparams} = convertBodyToQueryFormat(
        _request,
        'JobAdvert',
        'advertid',
      );

      const result = queryDb(sql, [...sqlparams, _request.params.advertid]);

      console.log(result);

      response.status(200).json({
        success: true,
        message: 'Updated advert successfully',
      });
    } catch (error: unknown) {
      next(error);
    }
  },
};
              </code>
            </pre>
          </div>
        </details>
        <h3>Sql</h3>
        <p>Sql-kielestä opin myös uusia asioita. Yksi näistä oli tietokannan eventit eli tapahtumat, joita ajetaan esimerkiksi kellonajan perusteella. Eventeistä minulla ei ollut aiempaa kokemusta. Eventit olivat tarpeellisia projektissa, koska vanhentuneet toimeksiantoilmoitukset pitää piilottaa näkyvistä automaattisesti. Tätä varten loin eventin, joka ajetaan päivittäin heti keskiyön jälkeen.</p>
        <div class="smallimg">
          <img src="./img/sqlevent.png" alt="sql-event">
        </div>
       
        
        <p>Asia mistä opin paljon lisää olivat proceduurit. Proceduurit olivat järkevä tapa toteuttaa tiettyjä toimenpiteitä kuten profiilin poistaminen, koska proceduuriin oli helppo lisätä transaktio. Proceduurin tekeminen selkeytti ja lyhensi myös backendin koodia.</p>
        <div class="smallimg">
          <img src="./img/proceduuri.png" alt="proceduuri">
        </div>
       
        
        <p>Proceduurin käyttö backend koodissa profiili kontrollerissa.</p>
        <div class="code">
        <pre>
            <code class="language-typescript">
// Deletes profile by id
async deleteProfile(
_request: express.Request,
response: express.Response,
next: express.NextFunction,
) {
try {
  // Calls database procedure which deletes all profile data with given profile id.
  // Procedure wrappes delete queries in transaction and rollbacks if anything fails.
  const result = await queryDb('CALL deleteProfile(?);', [
    _request.params.profileid,
  ]);

  console.log(result);

  response.status(200).json({
    message: 'Deleted profile succesfully',
    success: true,
  });
} catch (error: unknown) {
  next(error);
}
}                   

            </code>
        </pre>
        </div>
      <p>Ylläolevan koodin queryDB-funktio on oma tekemäni funktio, jolla saadaan yhteys tietokantaan ja lähetettyä haluttu kysely siihen. Tietokantaan muodostetaan connection pool, joka mahdollistaa samojen yhteyksien käytön uudestaan sen sijaan että ne suljettaisiin aina käytön jälkeen.</p>
  
      <details>
    <summary>Koodi avautuu tästä</summary>
      <div class="code">
      <pre>
          <code class="language-typescript">
// Create mysql connection pool
const pool: mysql.Pool = mysql.createPool({
  connectionLimit: 1,
  host: process.env.HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB,
});

// Type for database query return object field
type ResultField = string | boolean | number;
// Type for database query return object
type DbResult = Record &lt;string, ResultField&gt;;

/**
 * Function to create connection and send query to database
 * @param {string} query sql query
 * @param {Array} parameters array of values that replaces "?" in sql query
 * @return {Promise} promise with data returned from database
 */
const queryDb = async (query: string, parameters: unknown[]) => {
  return new Promise<[DbResult]>((resolve, reject) => {
    // Get pool connection
    pool.getConnection(async (error, connection) => {
      // If error throw error forward
      if (error) {
        throw error;
      } else {
        console.log('Db connection successfull');
      }

      // Send query to database with parameters
      connection.query(query, parameters, (error: unknown, result) => {
        // If error reject promise
        if (error) {
          reject(error);
        } else {
          // Check that query doesn't return undefined
          // In case of undefined release connection and reject promise
          if (typeof result === 'undefined') {
            connection.release();
            reject(new TypeError('Query returned undefined value'));
          }

          // Release connection after successfull query
          connection.release();
          // In case of successfull query resolve promise wiht result
          resolve(result);
        }
      });
    });
  });
};

export default queryDb;

          </code>
        </pre>
      </div>
    </details>
    <h3>Funktioita ja validointia</h3>
      <div>
            <p>Projektin aikana oli myös tarpeellista tehdä funktioita sekä middlewareja, jotta koodia saatiin siistimmäksi ja modulaarisemmaksi.</p>
           <p>Alla oleva funktio muuttaa minkä kokoisen objektin tahansa sql update lauseeksi ja sen parametreiksi mysql-kirjaston mukaisella tavalla.</p> 
           <details> 
            <summary>Koodi avautuu tästä</summary>
           <div class="code">
            <pre>
            <code class="language-typescript">
const convertBodyToQueryFormat = (
  request: express.Request,
  tablename: string,
  idcolumnname: string,
) => {
  if (!request.body) {
    throw new Error('No body received in request');
  }

  // Take values values from object to array
  const values: unknown[] = Object.values(request.body);
  // Take keys(columns) from object to array
  const keys = Object.keys(request.body);

  // Updatestring will contain update query
  // It is contructed from values and keys separated from object
  // This allows to use this route to update any number of columns in table row

  // Start string of the query
  let sql = 'UPDATE ' + tablename + ' SET ';
  // Add each of keys(column names) one by one into updatestring
  for (const x of keys) {
    sql += String(x) + ' = ?';
    // If added last key then insert just ' ' otherwise ',' is needed
    sql += keys.indexOf(x) === keys.length - 1 ? ' ' : ', ';
  }

  // Last part of update string where you specify profile id
  sql += 'WHERE ' + idcolumnname + ' = ?;';

  return {
    sql: sql,
    sqlparams: values,
  };
};
            </code>
          </pre>
            </div>
          </details>
            <p>Alla oleva bodyChecker on middleware, joka tarkistaa ettei vastaanotetun pyynnön bodyssä ole undefined tai null arvoja.</p>
            <details>
              <summary>Koodi avautuu tästä</summary>
            <div class="code">
              <pre>
                <code class="language-typescript">
const bodyChecker = (
  _request: express.Request,
  _response: express.Response,
  next: express.NextFunction,
) => {
  try {
    const values = Object.values(_request.body);

    if (
      values.includes(undefined) ||
      values.includes(null) ||
      values.includes('undefined') ||
      values.includes('null')
    ) {
      throw new Error('Undefined or null values in body');
    } else {
      next();
    }
  } catch (error: unknown) {
    next(error);
  }
};

                </code>
              </pre>

            </div>
          </details>
        </div>
        <p>Datan validointi oli myös tärkeässä osassa sovelluksen toimivuuden ja tietoturvan kannalta. Kehityksen aikana tässä auttoivat typescriptin tyypit. Koska typescript käännetään javascriptiksi ennen kuin se voidaan suorittaa, täytyi myös TS:n tyyppien lisäksi tehdä validoinnit perinteisellä javascriptillä esimerkiksi tietokannan insert lauseiden yhteydessä.</p>
        <p>Validoinnistakin opin paljon uutta ja varsinkin siitä, kuinka tärkeää se on laajemman mittakaavan sovelluksessa. Monet sattuneista virheistä johtuivatkin juuri validoinnin puutteesta.</p>'
        <p>Validoinnissa minulla on myös vielä kehitettävää tarkkuudessa. Sovelluksemme kaatui loppuesityksessä ja osasyynä siihen oli se ettei paikkakunnan nimen olemassaoloa tietokannassa tarkistettu toimeksiantoilmoitusta lähetettäessä. Olemalla tarkempi ja kunnollisilla testeillä tämäkin virhe oltaisiin voitu välttää.</p>
        <p>Validoinnissa käytettiin muunmuassa factory functioita jotka filtteröivät ei toivotut tiedot pois objectista. Alla esimerkki toimeksiantoilmoituksen factorystä.</p>
      <details>
        <summary>Koodi avautuu tästä</summary>
        <div class="code">
        <pre>
            <code class="language-typescript">
// Factory function is used to make sure there are no unwanted fields in object which contains new advert.
// Factory function also places default values into object keys if no value is given.
const jobadvertFactor = ({
  advertid = '',
  firstname = '',
  familyname = '',
  company = null,
  startdate = null,
  email = 'esimerkki@sahkoposti.com',
  phonenumber = '000-0000-0000',
  jobtitle = '',
  description = '',
  salary = '',
  validuntil = '0000-00-00',
  isvalid = true,
  accepted = false,
  city = '',
}: Jobadvert): Jobadvert => ({
  advertid,
  firstname,
  familyname,
  company,
  startdate,
  email,
  phonenumber,
  jobtitle,
  description,
  salary,
  validuntil,
  isvalid,
  accepted,
  city,
});

            </code>
        </pre>
        </div>
      </details>
        <p>Tyypit tarkistetaan myös javascriptillä virheiden välttämiseksi ja tietoturvan takia. Sitä varten luotiin yksinkertaisia funktioita tarkistusta varten.</p>
        <details>
          <summary>Koodi avautuu tästä</summary>
        <div class="code">
        <pre>
      <code class="language-typescript">
export const userTypeChecker = (user: User) => {
  if (
    typeof user.email !== 'string' ||
    typeof user.admin !== 'boolean' ||
    typeof user.schoolname !== 'number'
  ) {
    return false;
  }

  return true;
};
      </code>
    </pre>
        </div>
      </details>
         

            
        
            
  
<h3>AWS palvelut koodiin</h3>
<p>Kun Tietokanta oli luotu ja backendiin oli tehty perustoiminnallisuudet sen käsittelyyn, alettiin rakentamaan AWS:n palveluita.</p>
<p>En ennen tätä projektia ollut juurikaan pystyttänyt saati käyttänyt AWS:n palveluita joten tässäkin kohtaa aikaa meni paljon opetteluun, tutoriaaleihin ja kokeiluun.</p>
<p>AWS:n palveluita pystyy käyttämään aws-sdk kirjaston avulla. Cognito palvelun käyttöön on olemassa myös oma amazon-cognito-identity-js kirjasto. Kumpaakin on käytetty projektissa ja molemmat ovat esimerkkejä niistä kirjastoista, jotka olivat minulle entuudestaan täysin vieraita. Opetteluun meni paljon aikaa, mutta onnistuin kuitenkin ottamaan niiden käytön hyvin haltuun projektimme vaatimien palveluiden osalta.</p>
<p>Sovellus käyttää myös kahta S3 buckettia. Sovelluksen frontend tarjoillaan toisesta bucketista ja toinen bucketti on profiilikuvien tallennusta varten.</p>
           
<p>Sovellus käyttää simple email service palvelua sähköpostien lähettämiseen. Sähköposteja lähetetään toimeksiantajille heidän julkaistessaan ilmotuksia ja opiskelijoille käyttäjätilin vahvistuksen sekä salasanan nollauksen yhteydessä.</p>

            <p>Sovelluksen käyttäjätilien hallintaan valittiin aws:n palvelu cognito. Valmis palvelu oli järkevää valita sen sijasta että käyttäjätilejä tallennettaisiin itse tietokantaan, koska valmis palvelu on tietoturvallisempi ja esimerkiksi salasanojen encryptauksesta ei tarvitse itse huolehtia.</p>
            <p>Kaikki palvelut pystytettiin aws:n konsolissa ja niille luotiin iam-käyttäjät, joiden kautta palveluita voidaan käyttää koodissa.</p>
            <p>Alla on esimerkkinä luokka, joka sisältää sovelluksessamme tarvittavat metodit käyttäjien hallintaan.</p>
            <p>Myös kaikkien muiden palveluiden (S3, SES) hallinta on toteutettu vastaavien luokkien avulla.</p>
           
            <details>
              <summary>Koodi avautuu tästä</summary>
            <div class="code">
            <pre>
                <code class="language-typescript">

/**
 * Class for using cognito services
 */
class CognitoHelper {
  public userPool: CognitoUserPool;
  public cognitoIdentity: CognitoIdentityServiceProvider;

  /**
   * Constructor function. Creates new cognitoUserPool and CognitoIdentityServiceProvider.
   */
  constructor() {
    this.userPool = new CognitoUserPool({
      UserPoolId: process.env.USER_POOL_ID ?? '',
      ClientId: process.env.CLIENT_ID ?? '',
    });
    this.cognitoIdentity = new CognitoIdentityServiceProvider({
      accessKeyId: process.env.COGNITO_ACCESS_KEY,
      secretAccessKey: process.env.COGNITO_SECRET_KEY,
      region: process.env.REGION,
    });
  }

  /**
   * Method that signs new user to cognito and database
   * @param {string} email users email
   * @param {string} password users password
   * @return {Promise} resolved promise
   */
  async signUp(email: string, password: string) {
    return new Promise((resolve, reject) => {
      const attributeList: CognitoUserAttribute[] = [
        new CognitoUserAttribute({
          Name: 'email',
          Value: email,
        }),
      ];

      // Signup user to cognito
      this.userPool.signUp(
        email,
        password,
        attributeList,
        [],
        (error, result) => {
          if (error) {
            reject(error);
          }

          // If signup was succesfull return username
          resolve(result?.user.getUsername());
        },
      );
    });
  }

  /**
   * Method that confirms user registration with code that cognito sent via email
   * @param {string} email users email
   * @param {string} code users confirmation code received via email
   * @return {Promise} resolved promise
   */
  async confirmSignUp(email: string, code: string) {
    // Create new instance of CognitoUser
    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      // Use cognitoUser class method to verify confirmation code
      cognitoUser.confirmRegistration(code, true, (error, result) => {
        if (error) {
          reject(error);
        }

        resolve(JSON.stringify(result));
      });
    });
  }

  /**
   * Method to resend confirmation code to user
   * @param {string} email users email
   * @return {promise} resolved promise
   */
  async resendConfirmCode(email: string) {
    // Create new instance of CognitoUser

    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      // Use class method to resend confirmation code
      cognitoUser.resendConfirmationCode((error, result) => {
        if (error) {
          reject(error);
        }

        resolve(JSON.stringify(result));
      });
    });
  }

  /**
   * Method to sign user in
   * @param {string} email users registered email
   * @param {string} password users password
   * @return {Promise} resolved promise
   */
  async signIn(email: string, password: string) {
    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      const authenticationDetails = new AuthenticationDetails({
        Username: email,
        Password: password,
      });

      this.cognitoIdentity.adminGetUser(
        {
          UserPoolId: process.env.USER_POOL_ID || '',
          Username: email || '',
        },
        (error) => {
          if (error) reject(error); // an error occurred
        },
      );

      cognitoUser.authenticateUser(authenticationDetails, {
        // If sign in was success check if user has confirmed their account with code
        onSuccess(session, userConfirmationNecessary) {
          if (userConfirmationNecessary) {
            resolve({userConfirmationNecessary});
          }

          // In case of everything is ok send token of signed in user forward

          resolve({
            accessToken: session.getAccessToken().getJwtToken(),
          });
        },
        onFailure(error) {
          reject(error);
        },
      });
    });
  }

  /**
   * Method that signs user out
   * @param {string} email users email
   * @return {Promise} resolved promise
   */
  async signOut(email: string) {
    return new Promise((resolve) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      cognitoUser.signOut(() => {
        resolve('Signed out successfully');
      });
    });
  }

  /**
   * Method to for authenticated user to delete their account/data from cognito and database
   * @param {string} email users email
   * @param {string} password users password fro authentication
   * @return {Promise} promise
   */
  async deleteUser(email: string, password: string) {
    return new Promise((resolve, reject) => {
      // Create new instance of cognitoUser
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });
      // Details for authentication
      const authenticationDetails = new AuthenticationDetails({
        Username: email,
        Password: password,
      });

      // Try to authenticate user
      cognitoUser.authenticateUser(authenticationDetails, {
        // If sign in was success check if user has confirmed their account with code
        onSuccess(_session, userConfirmationNecessary) {
          if (userConfirmationNecessary) {
            resolve({userConfirmationNecessary});
          }

          // On successfull login delete user
          cognitoUser.deleteUser((error, result) => {
            if (error) {
              reject(error);
            }

            console.log(result);

            resolve(result);
          });
        },
        onFailure(error) {
          reject(error);
        },
      });
    });
  }

  /**
   * Method to start password reset workflow. This will send email with confirmation code to user
   * @param {string} email users email
   * @return {Promise} promise
   */
  async resetPassword(email: string) {
    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });

      this.cognitoIdentity.adminGetUser(
        {
          UserPoolId: process.env.USER_POOL_ID || '',
          Username: email || '',
        },
        (error) => {
          if (error) reject(error); // an error occurred
        },
      );

      cognitoUser.forgotPassword({
        onSuccess: function (result) {
          console.log('call result: ' + result);
          resolve(result);
        },
        onFailure: function (error) {
          reject(error);
        },
      });
    });
  }

  /**
   * Method to complete password reset request
   * @param {string} email users email
   * @param {string} confirmationCode password reset confirmation code received via email
   * @param {string} newPassword new password provided by user
   * @return {promise} promise
   */
  async confirmPassword(
    email: string,
    confirmationCode: string,
    newPassword: string,
  ) {
    return new Promise((resolve, reject) => {
      const cognitoUser = new CognitoUser({
        Username: email,
        Pool: this.userPool,
      });
      cognitoUser.confirmPassword(confirmationCode, newPassword, {
        onFailure(error) {
          reject(error);
        },
        onSuccess() {
          resolve('Password reset success');
        },
      });
    });
  }
}



                </code>
            </pre>
            </div>
            
          </details>
        
        <h2>testaus</h2>
     <div class="backend-grid">
            <div>
                <p>Sivuroolini projektissa oli testaaja. Projektin alussa kirjoitettiin testaussuunnitelma, joka sisälsi muunmuassa eri testaustyypit ja ohjeet dokumentaatioon.</p>
                <p>Projektissamme oli kaksi testaajaa ja minun tehtävänäni oli pääasiassa backend-sovelluksen testaus. Testausta toteutin lähinnä tekemällä yksikkötestejä. Yksikkötestit toteutettiin mocha & chai sekä supertest kirjastojen avulla.</p>
                <p>Tein myös zenhubiin bugit osion, joka toimi projektin bug trackerinä. Ohjeet bugien ilmoittamiseen laadittiin testaussuunnitelmaan.</p>
                <p>Projektin alussa tiesin lähinnä testauksen käsitteistöä ja osasin kirjoittaa hyvin yksinkertaisia testejä mocha & chai kirjastoilla. Vaikka testaus projektissa jäi lopuksi vähemmälle kuin olisin toivonut, oli se silti opettavainen kokemus ja varsinkin minulle uusi supertest kirjasto osoittautui hyödylliseksi.</p>
                <p>Myönnän että testaus projektissamme ei toteutunut toivotulla tavalla. Testausta olisi ehdottomasti pitänyt toteuttaa enemmän projektin aikana ja se onkin yksi asioista minkä tekisin toisin jos saisin aloittaa projektin alusta.</p>
            </div>
       
           
            <div class="code">
            <pre>
                <code class="language-javascript">
    it('Insert profile', (done) => {
    request(app)
      .post('/profiles')
      .set('Authorization', token)
      .send({
        email: 'testaus@gmail.com',
      })
      .set('Accept', 'application/json')
      .expect('Content-Type', /json/)
      .expect(201)
      .end((err, res) => {
        if (err) {
          return done;
        }

        expect(JSON.parse(res.text).success).to.be.true;
        return done();
      });
  });

  it('Update profile', async () => {
    const id = await request(app)
      .get('/profiles/user/email/')
      .set('Authorization', token);

    const result = await request(app)
      .put('/profiles/' + JSON.parse(id.text)[0].userprofileid)
      .set('Authorization', token)
      .send({
        firstname: 'Anneli',
        familyname: 'Auvikainen',
        phonenumber: '0458263328',
        aboutme: 'Olen anneli',
        lookingfor: 'Jotain töitä emt.',
        studyfield: 'joku',
        yearofstudy: 2,
        public: true,
        picturelink: 'anneli.photo',
        email: 'anneli.anneli@gmail.com',
      })
      .set('Accept', 'application/json')
      .expect('Content-Type', /json/)
      .expect(200);

    expect(JSON.parse(result.text).success).to.be.true;
  });


                </code>
            </pre>
            </div>
      
        </div>
        <h2>Muuta</h2>
      
        <h3>Frontend</h3>
            <div>
            <p>Pääsin myös toteuttamaan jonkin verran frontend kehitystä projektin aikana.</p>
            <p>Olin tarpeen mukaan frontend-kehittäjien tukena kun backendin toiminnallisuuksia yhdistettiin frontendiin.</p>
            <p>Projektin loppuvaiheessa pääsin myös tekemään sovellukseemme ohjesivut ja osan etusivusta angular frameworkilla.</p>
            <p>Korjasin myös satunnaisia bugeja joita ilmeni esimerkiksi käyttäjätestauksen myötä.</p>
            <p>Frontend kehityksessä minulla on vielä selkeästi kehittymisen varaa koska olen opinnoissani suuntaunut pääasiassa backend puolelle.</p>
            <h3>Ohjesivu sovelluksessamme</h3>
            <img src="./img/ohjesivu.png" alt="ohjesivu">
          </div>

          <h3>Git ja github</h3>
          <p>Gitin ja githubin käyttö oli minulle pääosin vierasta ennen projektia, mutta projektin aikana opin käyttämään hyvin niiden perustoimintoja. </p>
     
            <h2>Tavoitteiden saavuttaminen</h2>
            <p>Saavutin mielestäni asettamani tavoitteet hyvin. Opin paljon uutta backend-ohjelmoinnista ja varsinkin pilvipalvelujen hyödyntämisestä siinä. Opin myös tietoturvasta ja sen toteuttamisesta sekä esimerkiksi gdpr:n asettamista vaatimuksista. Pääsin myös tutustumaan frontend kehitykseen ja frontend sovelluksen yhdistämisestä backendiin. Sql-kielestä opin uutta ja syvensin aiempaa osaamista paljon. Myös tietokannan suunnittelusta ja varsinkin suunnittelun tärkeydestä opin huomattavasti.</p>
            <p>Ryhmätyötaitoni kehittyivät projektin aikana, koska työskentely vaati hyvin paljon kommunikointia muiden ryhmäläisten kanssa. Tässä auttoi myös projektissa käytetty scrum-metodi, jonka käytöstä opin myös paljon.</p>
            
            <h2>Missä voisin/haluaisin vielä kehittyä</h2>
            <p>Virheenkäsittelyssä olisi vielä parantamisen varaa. Vaikka virheenkäsittely oli sovelluksessa pääosin hyvää, jäi joitain asioita tekemättä tai ne oli tehty huonosti. Tästä esimerkkinä toimeksiantoilmoitusta lisättäessä olisi myös backendin päässä pitänyt tarkastaa onko kaupunkia, johon ilmoitus yritetään tehdä olemassa. Myös esimerkiksi käyttäjän koulunvaihto toiminnallisuuden virheenkäsittelyssä olisi parantamisen varaa, koska nykymuodossaan virheen sattuessa vaaditaan todennäköisesti yhteydenotto asiakaspalveluun.</p>
            <p>Koodin siisteyttä olisi myös voinut parantaa. Koodiin jäi joitakin vanhoja käyttämättömiä osia jotka olisi voinut poistaa sen selkeyttämiseksi.</p>
            <p>Kommunikaatio eri ryhmäläisten ja roolien välillä on kehityskohde myös itselläni. Vaikka ryhmämme toimi pääasiassa hyvin, luotimme liikaa toisiimme ja sen takia sattui paljon ylimääräisiä virheitä. Minun olisi myös teknisenä ihmisenä pitänyt osallistua heti alusta pitäen taskien määrittelyyn.</p>
            <h2>Työnäkymät</h2>
            <p>Ticorporate vahvisti kiinnostustani backend-kehitykseen entisestään. Projekti toi myös uuden mielenkiinnon kohteen eli pilvipalvelut ja niiden hyödyntäminen backend kehityksessä. Aioinkin näillä näkymin jatkaa urapolkuani backend-koodarina sekä pilvipalveluiden kehittäjänä.</p>
        
        </div>
        <script src="./prism.js"></script>
</body>
</html>
